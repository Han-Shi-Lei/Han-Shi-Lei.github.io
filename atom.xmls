<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lovemonths</title>
  
  
  <link href="/atom.xmls" rel="self"/>
  
  <link href="http://lovemonths.com/"/>
  <updated>2019-04-17T13:33:57.888Z</updated>
  <id>http://lovemonths.com/</id>
  
  <author>
    <name>������</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用栈、递归实现二叉树的前序、中序、后序遍历</title>
    <link href="http://lovemonths.com/2019/04/17/newpapername/"/>
    <id>http://lovemonths.com/2019/04/17/newpapername/</id>
    <published>2019-04-17T13:26:51.000Z</published>
    <updated>2019-04-17T13:33:57.888Z</updated>
    
    <content type="html"><![CDATA[<p>##题目一：二叉树的前序遍历</p><p>给定一个二叉树，返回它的前序遍历<br>示例：<br>输入: [1,null,2,3]<br>1</p><p>2<br>/<br>3</p><p>输出: [1,2,3]<br>代码实现如下：</p><p><code>/**</code></p><ul><li><p><code>Definition for a binary tree node.</code></p></li><li><p><code>struct TreeNode {</code></p></li><li><p><code>int val;</code></p></li><li><p><code>TreeNode *left;</code></p></li><li><p><code>TreeNode *right;</code></p></li><li><p><code>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</code></p></li><li><p><code>};</code><br> <code>*/</code><br> <code>class Solution {</code><br> <code>public:</code><br> <code>vector&lt;int&gt; preorderTraversal(TreeNode* root) {</code></p><pre><code>stack&lt;TreeNode*&gt; st;vector&lt;int&gt; v;if(root == nullptr){    return v;}if(root != nullptr){    //先将跟压到栈中    st.push(root);    while(!st.empty()){        TreeNode* cur = st.top();        //取出根并将根尾插到vector中        v.push_back(cur-&gt;val);        st.pop();        //先将cur-&gt;right压到栈中        if(cur-&gt;right){            st.push(cur-&gt;right);        }        //再将cur-&gt;left压到栈中，此时cur-&gt;left再栈顶，下次取出        //cur-&gt;left尾插到vector中，当左子树全部被取完，然后取右子        //树        if(cur-&gt;left){            st.push(cur-&gt;left);        }    }}return v;</code></pre><p> <code>}</code><br> <code>};</code></p><p> ##题目二：二叉树的中序遍历</p></li></ul><p>给定一个二叉树，返回它的中序遍历。<br>示例：<br>输入: [1,null,2,3]<br>1</p><p>2<br>/<br>3</p><p>输出: [1,3,2]<br>代码实现如下：</p><p><code>/**</code></p><ul><li><code>Definition for a binary tree node.</code></li><li><code>struct TreeNode {</code></li><li><code>int val;</code></li><li><code>TreeNode *left;</code></li><li><code>TreeNode *right;</code></li><li><code>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</code></li><li><p><code>};</code><br> <code>*/</code><br> <code>class Solution {</code><br> <code>public:</code><br> <code>vector&lt;int&gt; inorderTraversal(TreeNode* root) {</code></p><pre><code>stack&lt;TreeNode*&gt; st;vector&lt;int&gt; v;TreeNode* p = root;if(nullptr == root){    return v;}if(nullptr != root){    while(p != nullptr || !st.empty()){        //p不为空，压入栈中，p走左子树，将左子树全部压到栈中        while(p != nullptr){            //先压根            st.push(p);            p = p-&gt;left;        }        //取出栈顶元素给p，并将栈顶元素取出插入到vector中         p = st.top();        v.push_back(p-&gt;val);        st.pop();        //取出p-&gt;right压到栈中        p = p-&gt;right;    }}return v;</code></pre><p> <code>}</code><br> <code>};</code></p><p> ##题目三：二叉树的后序遍历</p></li></ul><p>给定一个二叉树,返回它的后序遍历。<br>示例：<br>输入: [1,null,2,3]<br>1</p><p>2<br>/<br>3</p><p>输出: [3,2,1]<br>用两个栈和递归实现二叉树的后续遍历。<br>代码实现如下：</p><p><code>/**</code></p><ul><li><code>Definition for a binary tree node.</code></li><li><code>struct TreeNode {</code></li><li><code>int val;</code></li><li><code>TreeNode *left;</code></li><li><code>TreeNode *right;</code></li><li><code>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</code></li><li><code>};</code><br> <code>*/</code><br> <code>class Solution {</code><br> <code>public:</code><br> <code>vector&lt;int&gt; postorderTraversal(TreeNode* root) {</code><pre><code>stack&lt;TreeNode*&gt; s1;stack&lt;TreeNode*&gt; s2;vector&lt;int&gt; res;if(!root){    return res;}s1.push(root);while(!s1.empty()){    TreeNode* cur = s1.top();    s1.pop();    s2.push(cur);    //先将left压到栈里，再将right压到栈里，然后取出将右子树压到s2    //中，最后再压左子树    //待右子树全部压完，然后将左子树全部压到栈s2中    //此时栈s2从上到下依次是左子树、右子树、根    if(cur-&gt;left){        s1.push(cur-&gt;left);    }    //后压右子树，然后全部将有子树压到栈s2中    if(cur-&gt;right){        s1.push(cur-&gt;right);    }}while(!s2.empty()){    //弹出s2栈顶元素，依次尾插到vector中，最终得到二叉树的后序    //遍历    res.push_back(s2.top()-&gt;val);    s2.pop();}return res;</code></pre> <code>}</code><br> <code>};</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##题目一：二叉树的前序遍历&lt;/p&gt;
&lt;p&gt;给定一个二叉树，返回它的前序遍历&lt;br&gt;示例：&lt;br&gt;输入: [1,null,2,3]&lt;br&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;br&gt;/&lt;br&gt;3&lt;/p&gt;
&lt;p&gt;输出: [1,2,3]&lt;br&gt;代码实现如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/**&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://lovemonths.com/tags/C/"/>
    
  </entry>
  
</feed>
