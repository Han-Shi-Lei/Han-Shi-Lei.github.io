<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lovemonths</title>
  
  
  <link href="/atom.xmls" rel="self"/>
  
  <link href="http://lovemonths.com/"/>
  <updated>2019-05-21T08:42:51.569Z</updated>
  <id>http://lovemonths.com/</id>
  
  <author>
    <name>������</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>匿名管道和命名管道</title>
    <link href="http://lovemonths.com/2019/05/21/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93/"/>
    <id>http://lovemonths.com/2019/05/21/匿名管道和命名管道/</id>
    <published>2019-05-21T08:41:58.000Z</published>
    <updated>2019-05-21T08:42:51.569Z</updated>
    
    <content type="html"><![CDATA[<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><p>功能：创建一条无名管道</p><p>原型：int pipe(int fd[2]);    </p><p>参数：fd：文件描述符数组,其中fd[0]表示读端, fd[1]表示写端 </p><p>返回值:成功返回0，失败返回错误代码   </p><p><strong>管道的读写规则</strong></p><p> 当没有数据可读时</p><p> O_NONBLOCK disable：read调用阻塞，即进程暂停执行，一直等到有数据来到为止。</p><p> O_NONBLOCK enable：read调用返回-1，errno值为EAGAIN。</p><p> 当管道满的时候 </p><p>O_NONBLOCK disable： write调用阻塞，直到有进程读走数据 </p><p>O_NONBLOCK enable：调用返回-1，errno值为EAGAIN</p><p> 如果所有管道写端对应的文件描述符被关闭，则read返回0 </p><p> 如果所有管道读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE,进而可能导致write进程 退出 </p><p>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。 </p><p>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性    </p><p><strong>管道特点</strong></p><p>只能用于具有共同祖先的进程（具有亲缘关系的进程）之间进行通信；通常，一个管道由一个进程创 建，然后该进程调用fork，此后父、子进程之间就可应用该管道。</p><p> 管道提供流式服务 一般而言，进程退出，管道释放，所以管道的生命周期随进程 </p><p>一般而言，内核会对管道操作进行同步与互斥 </p><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道    </p><h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><p>命名管道：可以用于任意进程之间的通信（fifo）。</p><p><strong>创建一个命名管道</strong></p><p>命令行创建</p><p>mkfifo filename    </p><p>程序内创建</p><p>int mkfifo(const char *filename,mode_t mode);    </p><p>参数：filename管道文件的路径名，mode管道文件的权限</p><p><strong>命名管道的打开规则</strong></p><p>1、若管道文件没有被以写的方式打开，则以只读打开会阻塞 </p><p>2、若管道文件没有被以读的方式打开，则以只写打开会阻塞 </p><h4 id="匿名管道和命名管道的区别（打开和创建的方式不同）"><a href="#匿名管道和命名管道的区别（打开和创建的方式不同）" class="headerlink" title="匿名管道和命名管道的区别（打开和创建的方式不同）"></a>匿名管道和命名管道的区别（打开和创建的方式不同）</h4><p>1.匿名管道由pipe函数创建并打开</p><p>2.命名管道由mkfifo函数创建，打开用open</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;匿名管道&quot;&gt;&lt;a href=&quot;#匿名管道&quot; class=&quot;headerlink&quot; title=&quot;匿名管道&quot;&gt;&lt;/a&gt;匿名管道&lt;/h4&gt;&lt;p&gt;功能：创建一条无名管道&lt;/p&gt;
&lt;p&gt;原型：int pipe(int fd[2]);    &lt;/p&gt;
&lt;p&gt;参数：fd：文件
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://lovemonths.com/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://lovemonths.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>智能指针的使用和模拟实现</title>
    <link href="http://lovemonths.com/2019/05/16/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://lovemonths.com/2019/05/16/智能指针的使用和模拟实现/</id>
    <published>2019-05-16T13:40:57.000Z</published>
    <updated>2019-05-16T13:42:45.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="智能指针的使用和模拟实现"><a href="#智能指针的使用和模拟实现" class="headerlink" title="智能指针的使用和模拟实现"></a>智能指针的使用和模拟实现</h3><h4 id="RALL"><a href="#RALL" class="headerlink" title="RALL"></a>RALL</h4><p>RALL:是一种利用<strong>对象生命周期</strong>来控制程序资源的简单技术</p><p>在对象构造的时候获取资源，接着控制对资源的访问之在对象生命周期期间内始终保持有效，最后在对象析构的时候释放资源，这样做的好处有两个</p><p>1.不需要显示的释放内存</p><p>2.采用这种方式，对象所需的资源在生命周期内始终有效</p><p>举个例子（抛出异常无法释放内存）</p><pre><code>template&lt;class T&gt;class Smartptr{public:    Smartptr(T* ptr = nullptr)        :_ptr(ptr)    {    }    ~Smartptr()    {        if (_ptr)        {            delete _ptr;            cout &lt;&lt; &quot;delete[] &quot;&lt;&lt; endl;        }    }private:    T* _ptr;};double Division(int a, int b){    if (b == 0)        throw &quot;Division by zero condition!&quot;;    else        return ((double)a / (double)b);}void Func(){    int* array = new int[10];    memset(array, 0, sizeof(int)* 10);    Smartptr&lt;int&gt; s(array);    int len, time;    cin &gt;&gt; len &gt;&gt; time;    cout &lt;&lt; Division(len, time) &lt;&lt; endl;}int main(){    try    {        Func();    }    catch (const char* errmsg)    {        cout &lt;&lt; errmsg &lt;&lt; endl;    }    system(&quot;pause&quot;);    return 0；}</code></pre><h4 id="智能指针的原理"><a href="#智能指针的原理" class="headerlink" title="智能指针的原理"></a>智能指针的原理</h4><p>上述的SmartPtr还不能将其称为智能指针，因为它不具有指针的行为，所以必须重载解引用和-&gt;访问空间所指的内容才构成智能指针。</p><p>即在SmartPtr类中重载：</p><p>T&amp;   operator*（）{</p><p>​    return *_ptr;</p><p>}</p><p>T operator-&gt;(){</p><p>​    return _ptr;</p><p>}</p><h4 id="std-auto-ptr-C-98"><a href="#std-auto-ptr-C-98" class="headerlink" title="std::auto_ptr(C++98)"></a>std::auto_ptr(C++98)</h4><p>c++98库中提供的auto_ptr智能指针当其拷贝后就把元对象的指针悬空了，再通过原指着真访问资源时就会出现问题，所以这种指针不提倡使用。</p><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p>c++11中提供了更靠谱的unique_ptr</p><p>unique_ptr的设计思路简单粗暴就是防止拷贝，下面模拟实现一下它的原理：</p><pre><code>template &lt;class T&gt;class Unique_Ptr{public:    Unique_Ptr(T* ptr)        :_ptr(ptr)    {}    ~Unique_Ptr()    {        if(_ptr)        {            delete _ptr;            _ptr = nullptr;        }    }    //重载*  -&gt;    T&amp; operator*()    {        return *_ptr;    }    T* operator-&gt;()    {        return _ptr;    }private:    Unique_Ptr(const Unique_Ptr&lt;T&gt;&amp; up);    Unique_Ptr&lt;T&gt;&amp; operator=(const Unique_ptr&lt;T&gt;&amp; up);    \*Unique_Ptr(const Unique_Ptr&lt;T&gt;&amp; up)  = delete;    Unique_Ptr&lt;T&gt;&amp; operator=(const Unique_ptr&lt;T&gt;&amp; up) = delete;*/    T* _ptr;}</code></pre><h4 id="std-share-ptr"><a href="#std-share-ptr" class="headerlink" title="std::share_ptr"></a>std::share_ptr</h4><p>C++11中开始提供更靠谱的并且支持拷贝的shared_ptr </p><p>share_ptr的基本原理就是：：是通过引用计数的方式来实现多个shared_ptr对象之间共享资源。</p><ol><li>shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共享。</li><li>在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一。</li><li>如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源； </li><li>如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指 针了。</li></ol><p>模拟实现share_ptr如下：</p><pre><code>template &lt;class T&gt;class Share_Ptr{public:    //构造函数在第一次申请资源后调用    Share_Ptr(T* ptr)        :_ptr(ptr)        ,Use_Count(new int(1))        , _mtx(new mutex)    {}    Share_Ptr(const Share_Ptr&lt;T&gt;&amp; sp)        :_ptr(sp._ptr)        , Use_Count(sp.Use_Count)        , _mtx(sp._mtx)    {        //当前指向资源的引用计数加1        addRef();    }    Share_Ptr&lt;T&gt;&amp; operator=(const Share_Ptr&lt;T&gt;&amp; sp)    {        //对于两个智能指针管理同一片空间的情况，不需要进行赋值        if (_ptr != sp._ptr){            if (subRef() == 0)            {                delete _ptr;                delete Use_Count;                delete _mtx;            }            _ptr = sp._ptr;            Use_Count = sp.Use_Count;            _mtx = sp._mtx;            addRef();        }        return this;    }    int addRef()    {        _mtx-&gt;lock();        ++(*Use_Count);        _mtx-&gt;unlock();        return *Use_Count;    }    int subRef()    {        _mtx-&gt;lock();        --(*Use_Count);        _mtx-&gt;unlock();        return *Use_Count;    }    ~Share_Ptr()    {        if (subRef() == 0)        {            if (_ptr)            {                delete _ptr;                _ptr = nullptr;                delete _mtx;                _mtx = nullptr;                delete Use_Count;                Use_Count = nullptr;            }        }    }    //重载* -&gt;    T&amp; operator*()    {        return *_ptr;    }    T* operator-&gt;()    {        return _ptr;    }    int UseCount()    {        return *Use_Count;    }private:    T* _ptr;    int* Use_Count;    //加锁，给一个全局的锁代价太大    mutex* _mtx;};struct Date{    int _year;    int _month;    int _day;    ~Date()    {        cout &lt;&lt; &quot;~Date()&quot; &lt;&lt; endl;    }};void Fun(const Share_Ptr&lt;Date&gt;&amp; sp,int n){    for (int i = 0; i &lt; n; i++)        Share_Ptr&lt;Date&gt; spcopy(sp);}int main(){    Share_Ptr&lt;Date&gt; sp(new Date);    //Share_Ptr&lt;Date&gt; sp1(sp);    int n = 100000;    thread t1(Fun, sp, n);    thread t2(Fun, sp, n);    t1.join();    t2.join();    cout &lt;&lt; sp.UseCount() &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;智能指针的使用和模拟实现&quot;&gt;&lt;a href=&quot;#智能指针的使用和模拟实现&quot; class=&quot;headerlink&quot; title=&quot;智能指针的使用和模拟实现&quot;&gt;&lt;/a&gt;智能指针的使用和模拟实现&lt;/h3&gt;&lt;h4 id=&quot;RALL&quot;&gt;&lt;a href=&quot;#RALL&quot; cla
      
    
    </summary>
    
      <category term="C++学习" scheme="http://lovemonths.com/categories/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://lovemonths.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>分行从上到下打印二叉树</title>
    <link href="http://lovemonths.com/2019/05/13/%E5%88%86%E8%A1%8C%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://lovemonths.com/2019/05/13/分行从上到下打印二叉树/</id>
    <published>2019-05-13T06:33:20.000Z</published>
    <updated>2019-05-13T06:39:29.287Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目：分行从上到下打印二叉树"><a href="#题目：分行从上到下打印二叉树" class="headerlink" title="题目：分行从上到下打印二叉树"></a>题目：分行从上到下打印二叉树</h4><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>思路：为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前层还没有打印的节点数；另一个变量表示下一层节点的数目。</p><p>代码实现如下：</p><p><code>struct BinaryTreeNode{</code></p><p>​    <code>int                                                     m_nValue;</code></p><p>​    <code>BinaryTreeNode*                           m_pLeft;</code></p><p>​    <code>BinaryTreeNode*                  m_Right;</code></p><p><code>}</code></p><p><code>void  Print(BinaryTreeNode* pRoot){</code></p><p>​    <code>if(pRoot == nullptr)</code></p><p>​        <code>return;</code></p><p>​    <code>std::queue&lt;BinaryTreeNode*&gt;    nodes;</code></p><p>​    <code>nodes.push(pRoot);</code></p><p>​    <code>//表示下一层的节点数</code></p><p>​    <code>int    nextLevel = 0;</code></p><p>​    <code>//表示当前层中还没有打印的节点数</code></p><p>​    i<code>nt   toBePrinted = 1;</code></p><p>​    <code>while(!nodes.empty()){</code></p><p>​        <code>BinaryTreeNode* pNode = nodes.front();</code></p><p>​        <code>printf(&quot;%d &quot;,pNode-&gt;m_nvalue);</code></p><p>​        <code>if(pNode-&gt;m_pLeft != nullptr){</code></p><p>​            <code>nodes.push(pNode-&gt;m_pLeft);</code></p><p>​            <code>++nextLevel;</code>        </p><p>​        <code>}</code></p><p>​        <code>if(pNode-&gt;m_pRight != nullptr){</code></p><p>​            <code>nodes.push(pNode-&gt;m_pRight);</code></p><p>​            <code>++nextLevel;</code>        </p><p>​        <code>}</code></p><p>​        <code>nodes.pop();</code></p><p>​        <code>--toBePrinted;</code></p><p>​        <code>if(toBePrinted == 0){</code></p><p>​            <code>printf(&quot;\n&quot;);</code></p><p>​            <code>toBePrinted = nextLevel;</code></p><p>​            <code>nextLevel = 0;</code></p><p>​        <code>}</code></p><p>​    <code>}</code></p><p><code>}</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目：分行从上到下打印二叉树&quot;&gt;&lt;a href=&quot;#题目：分行从上到下打印二叉树&quot; class=&quot;headerlink&quot; title=&quot;题目：分行从上到下打印二叉树&quot;&gt;&lt;/a&gt;题目：分行从上到下打印二叉树&lt;/h4&gt;&lt;p&gt;从上到下按层打印二叉树，同一层的节点按从左到
      
    
    </summary>
    
      <category term="二叉树（剑指offer）" scheme="http://lovemonths.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%89%91%E6%8C%87offer%EF%BC%89/"/>
    
    
      <category term="剑指offer" scheme="http://lovemonths.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>内存分配和管理</title>
    <link href="http://lovemonths.com/2019/05/11/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86/"/>
    <id>http://lovemonths.com/2019/05/11/内存分配和管理/</id>
    <published>2019-05-11T09:33:06.000Z</published>
    <updated>2019-05-11T09:59:48.729Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a>内存分配和管理</h4><p>malloc、calloc、realloc、alloca</p><p>1.malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</p><p>2.calloc: 为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存每一位（bit)都初始化为0。</p><p>3.realloc:更改以前分配的内存长度（增加或减小），当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值不确定。</p><p>4.alloca:在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca不具有可移植性，而且没有在传统堆栈的机器上很难实现。alloca不宜使用在必须广泛移植的程序中。c99中支持变长数组（VLA），可以用来替代alloca。</p><p><strong>malloc        free</strong></p><p>用于分配、释放内存malloc、free使用</p><p>申请内存，确认是否申请成功</p><p><code>char    *str = (char*)malloc(100);</code></p><p>assert(str  !=  nullptr);</p><p>释放内存后指针置空</p><p><code>free(p);</code></p><p><code>p = nullptr;</code></p><p><strong>new         delete</strong></p><p>1.new/new[]:完成两件事，先底层调用malloc分配了内存，然后调用构造函数（创建对象）。</p><p>2.delete/delete[]:也完成两件事，先调用析构函数（清理资源），然后底层调用free释放空间。</p><p>3.new在申请内存时会自动计算所需字节数，而malloc则需要我们自己输入申请内存空间的字节数。</p><p>new      delete使用</p><p><code>int main(){</code></p><p><code>T*    t   = new    T();         //先内存分配，再构造函数</code></p><p><code>delete    t；                     //先析构函数，再内存释放</code></p><p><code>return 0;</code></p><p><code>}</code></p><p><strong>delete    this合法吗？</strong></p><p>合法，但：</p><p>1.必须保证this对象是通过new  （不是new[]、不是placement    new、不是栈上、不是全局、不是其他对象成员）分配的。</p><p>2.必须保证调用delete  this的成员函数是最后一个调用this的成员函数。</p><p>3.必须保证成员函数的delete  this后面没有调用this了。</p><p>4.必须保证delete  this后面没有人使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;内存分配和管理&quot;&gt;&lt;a href=&quot;#内存分配和管理&quot; class=&quot;headerlink&quot; title=&quot;内存分配和管理&quot;&gt;&lt;/a&gt;内存分配和管理&lt;/h4&gt;&lt;p&gt;malloc、calloc、realloc、alloca&lt;/p&gt;
&lt;p&gt;1.malloc：申请指定字
      
    
    </summary>
    
      <category term="面试题" scheme="http://lovemonths.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="C++面试题" scheme="http://lovemonths.com/tags/C-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>僵尸进程</title>
    <link href="http://lovemonths.com/2019/05/09/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <id>http://lovemonths.com/2019/05/09/僵尸进程/</id>
    <published>2019-05-09T12:16:01.000Z</published>
    <updated>2019-05-09T12:18:43.573Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是僵尸进程-ZOMBIE-？"><a href="#什么是僵尸进程-ZOMBIE-？" class="headerlink" title="什么是僵尸进程(ZOMBIE)？"></a>什么是僵尸进程(ZOMBIE)？</h4><p>当子进程（child process）先于父进程（parent process）退出，<strong>但是父进程没有调用wait/waitpid回收子进程的资源</strong>，则子进程变成僵尸进程。 </p><p>但是如果该进程的<strong>父进程已经结束，那该进程就不会变成僵尸进程，</strong>因为每个进程结束的时候，系统会扫描所有运行中的进程，看看有没有哪个进程是刚结束的进程的子进程，如果有就由Init来接管他，成为他的父进程。</p><h4 id="僵尸进程的危害是什么？"><a href="#僵尸进程的危害是什么？" class="headerlink" title="僵尸进程的危害是什么？"></a>僵尸进程的危害是什么？</h4><p>（1）进程的退出状态必须被维持下去，因为他要告诉关心它的进程（父进程），你交给我的任务，我办的怎 么样了。可父进程如果一直不读取，那子进程就一直处于Z状态？</p><p><strong>答：是的。</strong></p><p>（2）维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话 说，Z状态一直不退出，PCB一直都要维护？</p><p><strong>答：是的。</strong></p><p>（3）那一个父进程创建了很多子进程，就是不回收，是不是就会造成内存资源的浪费？</p><p><strong>答：是的。因为数据结构 对象本身就要占用内存，想想C中定义一个结构体变量（对象），是要在内存的某个位置进行开辟空 间</strong></p><p>（4）内存泄漏？</p><p><strong>答：是的</strong></p><h4 id="僵尸进程如何避免？"><a href="#僵尸进程如何避免？" class="headerlink" title="僵尸进程如何避免？"></a>僵尸进程如何避免？</h4><p>1、让僵尸进程的父进程来回收，父进程每隔一段时间来查询子进程是否结束并回收，调用wait()或者waitpid(),通知内核释放僵尸进程 。</p><p>2、采用信号SIGCHLD通知处理，并在信号处理程序中调用wait函数 。</p><p>3、让僵尸进程变成孤儿进程，就是让他的父亲先死。</p><p>4、如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是僵尸进程-ZOMBIE-？&quot;&gt;&lt;a href=&quot;#什么是僵尸进程-ZOMBIE-？&quot; class=&quot;headerlink&quot; title=&quot;什么是僵尸进程(ZOMBIE)？&quot;&gt;&lt;/a&gt;什么是僵尸进程(ZOMBIE)？&lt;/h4&gt;&lt;p&gt;当子进程（child pro
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://lovemonths.com/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://lovemonths.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序数组</title>
    <link href="http://lovemonths.com/2019/05/03/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://lovemonths.com/2019/05/03/合并两个有序数组/</id>
    <published>2019-05-03T13:03:00.000Z</published>
    <updated>2019-05-03T13:07:29.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个有序整数数组nums1 和 nums2,将nums2 合并到 nums1中，使得nums1成为一个有序数组。</p><p><strong>说明：</strong></p><p>初始化nums1和nums2的元素数量分别为m和n。</p><p>假设nums1有足够的空间（空间大小大于或等于m+n）来保存nums2中的元素。</p><p>示例：</p><p>输入：</p><p>nums1 = [1,2,3,0,0,0], m = 3</p><p>nums2 = [2,5,6],           n = 3</p><p>输出：</p><p>[1,2,2,3,5,6]</p><p>思路：因为nums1足够大能保存nums2中的元素，并且nums1和nums2都是有序数组，所以我们可以从最后合并两个数组到num1中。则：last = n + m - 1</p><p>代码实现如下：</p><p><code>class Solution {</code></p><p>​    <code>public:</code>     </p><p>​        <code>void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {</code>   </p><p>​                  <code>if(m == 0 &amp;&amp; n == 0)</code>            </p><p>​                <code>return；</code></p><pre><code>            `int last = n-- + m-- -1;`                 `while(n&gt;=0 &amp;&amp; m&gt;=0){`     </code></pre><p>​                        <code>if(nums1[m] &gt; nums2[n]){</code>         </p><p>​                            <code>nums1[last--] = nums1[m--];</code>     </p><p>​                       <code>}</code>            </p><p>​                 <code>else{</code>       </p><p>​                          <code>nums1[last--] = nums2[n--];</code>      </p><p>​                      <code>}</code>         </p><pre><code>          `}`  </code></pre><p>​                        <code>//都到这里如果num2没有比较完，则将num2插入到nums1，中</code>       </p><p>​            <code>while(n&gt;=0){</code>    </p><p>​                             <code>nums1[last--] = nums2[n--];</code>         </p><p>​            <code>}</code>     </p><p>​        <code>}</code> </p><p><code>};</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定两个有序整数数组nums1 和 nums2,将nums2 合并到 nums1中，使得nums1成为一个有序数组。&lt;/p&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
      <category term="数组（LeetCode）" scheme="http://lovemonths.com/categories/%E6%95%B0%E7%BB%84%EF%BC%88LeetCode%EF%BC%89/"/>
    
    
      <category term="LeetCode" scheme="http://lovemonths.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的进度条程序</title>
    <link href="http://lovemonths.com/2019/05/03/Linux%E4%B8%8B%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%A8%8B%E5%BA%8F/"/>
    <id>http://lovemonths.com/2019/05/03/Linux下的进度条程序/</id>
    <published>2019-05-03T06:06:06.000Z</published>
    <updated>2019-05-03T06:07:27.561Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux环境下写一个会变颜色的进度条程序：</p><p>​    Linux环境下有三种缓冲方式：1.无缓冲 2.行缓冲间 3.全缓冲 C语言中采用的是行缓冲。</p><p>​    \r是回车回到行首，而不会到达下一行，如果继续输出，则会造成覆盖，所以进度条选择用\r输出。</p><p>​    fflush(stdout)是清空缓冲，强制把结果输出到屏幕上。</p><p><code>#include &lt;stdio.h&gt;</code></p><p><code>#include &lt;unistd.h&gt;</code></p><p><code>#include &lt;stdlib.h&gt;</code></p><p><code>int main(){</code><br>    <code>char bar[102];</code><br>     <code>const char s[] = &quot;|/-\\&quot;;</code><br>     <code>memset(bar,0,sizeof(bar));</code><br>     <code>int rate = 0;</code><br>    <code>for(;rate &lt; 101;rate++){</code><br>      <code>if(rate &lt;= 20)</code><br>        <code>printf(&quot;[%d%%][%c]\033[31m[%s]\r&quot;,rate,s[rate%4],bar);</code><br>      <code>else if(rate &lt;= 60)</code><br>        <code>printf(&quot;[%d%%][%c]\033[33m[%s]\r&quot;,rate,s[rate%4],bar);</code><br>      <code>else</code><br>        <code>printf(&quot;[%d%%][%c]\033[32m[%s]\r&quot;,rate,s[rate%4],bar);</code><br>      <code>bar[rate] = &#39;#&#39;;</code><br>      <code>fflush(stdout);</code><br>      <code>usleep(100 * 1000);</code><br>      <code>printf (&quot;\033[0m&quot;);</code><br>    <code>}</code></p><p><code>printf(&quot;\n&quot;);</code></p><p><code>return 0;</code></p><p><code>}</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux环境下写一个会变颜色的进度条程序：&lt;/p&gt;
&lt;p&gt;​    Linux环境下有三种缓冲方式：1.无缓冲 2.行缓冲间 3.全缓冲 C语言中采用的是行缓冲。&lt;/p&gt;
&lt;p&gt;​    \r是回车回到行首，而不会到达下一行，如果继续输出，则会造成覆盖，所以进度条选择用
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://lovemonths.com/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://lovemonths.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>删除排序链表中重复元素</title>
    <link href="http://lovemonths.com/2019/04/29/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://lovemonths.com/2019/04/29/删除排序链表中重复元素/</id>
    <published>2019-04-29T10:15:23.000Z</published>
    <updated>2019-04-29T10:24:23.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 </p><p><strong>示例1：</strong></p><p>输入：1-&gt;1-&gt;2</p><p>输出：1-&gt;2</p><p><strong>示例2：</strong></p><p>输入：1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3</p><p>输出：1-&gt;2-&gt;3</p><p>找两个指针一个在前一个在后，如果链表的元素相等，则更新结点，如果不等则更新node和next节点。代码实现如下：</p><p><code>/**</code></p><p><code>Definition for singly-linked list.</code></p><p><code>struct ListNode {</code></p><p><code>int val;</code></p><p><code>ListNode *next;</code></p><p><code>ListNode(int x) : val(x), next(NULL) {}</code></p><p><code>};</code><br><code>*/</code><br><code>class Solution {</code><br><code>public:</code><br><code>ListNode* deleteDuplicates(ListNode* head) {</code><br>    <code>if(head == nullptr)</code><br>        <code>return head;</code><br>    <code>ListNode* node = head;</code><br>    <code>ListNode* next = head-&gt;next;</code><br>    <code>while(next != nullptr){</code><br>        <code>if(node-&gt;val == next-&gt;val){</code><br>            <code>next = next-&gt;next;</code><br>            <code>node-&gt;next = next;</code><br>        <code>}</code><br>        <code>else{</code><br>            <code>node = next;</code><br>            <code>next = next-&gt;next;</code><br>        <code>}</code><br>    <code>}</code><br>    <code>return head;</code><br><code>}</code><br><code>};</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="链表（LeetCode）" scheme="http://lovemonths.com/categories/%E9%93%BE%E8%A1%A8%EF%BC%88LeetCode%EF%BC%89/"/>
    
    
      <category term="LeetCode" scheme="http://lovemonths.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>回文链表</title>
    <link href="http://lovemonths.com/2019/04/29/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://lovemonths.com/2019/04/29/回文链表/</id>
    <published>2019-04-29T08:46:29.000Z</published>
    <updated>2019-04-29T09:07:07.083Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请判断一个链表是否为回文链表</p><p><strong>示例1：</strong></p><p>输入：1-&gt;2</p><p>输出：false</p><p><strong>示例2：</strong></p><p>输入：1-&gt;2-&gt;2-&gt;1</p><p>输出：true</p><p>在这里我想到了两种做法:</p><p><strong>第一种是快慢指针法，一个指针走一步另一个指针走两步，然后走的慢的指针最后就落到了最中间位置。代码实现如下：</strong></p><p><code>/**</code></p><ul><li><code>Definition for singly-linked list.</code></li><li><code>struct ListNode {</code></li><li><code>int val;</code></li><li><code>ListNode *next;</code></li><li><code>ListNode(int x) : val(x), next(NULL) {}</code></li><li><p><code>};</code><br> <code>*/</code><br> class Solution {<br> public:<br> bool isPalindrome(ListNode* head) {</p><pre><code> if(head == nullptr || head-&gt;next == nullptr)     return true; ListNode* p1 = head; ListNode* p2 = head; //p1走一步，p2走两步 while(p2 &amp;&amp; p2-&gt;next){     p1 = p1-&gt;next;     p2 = p2-&gt;next-&gt;next; } ListNode* node = p1-&gt;next; ListNode* next; p1-&gt;next = nullptr; //重置p1 while(node){     next = node-&gt;next;     node-&gt;next = p1;     p1 = node;     node = next; } p2 = head; //比较两个链表的val是否相等 while(p1){     if(p1-&gt;val != p2-&gt;val)         return false;     p1 = p1-&gt;next;     p2 = p2-&gt;next; } return true;</code></pre><p> }<br> };</p></li></ul><p><strong>第二种就是将链表的所有节点保存到string中，然后将string反转，再将反转之后的string与反转前的string做比较，如果相等则返回true；如果不等则返回false。</strong></p><p><code>/**</code></p><ul><li><code>Definition for singly-linked list.</code></li><li><code>struct ListNode {</code></li><li><code>int val;</code></li><li><code>ListNode *next;</code></li><li><code>ListNode(int x) : val(x), next(NULL) {}</code></li><li><code>};</code><br> <code>*/</code><br> class Solution {<br> public:<br> bool isPalindrome(ListNode* head) {<pre><code> string temp; ListNode* p=head; while(p != NULL){     temp += p-&gt;val;     p = p-&gt;next; } string t = temp; reverse(temp.begin(),temp.end()); if(t == temp)     return true; return false;</code></pre> }<br> };</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请判断一个链表是否为回文链表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：1-&amp;gt;2&lt;
      
    
    </summary>
    
      <category term="链表（LeetCode）" scheme="http://lovemonths.com/categories/%E9%93%BE%E8%A1%A8%EF%BC%88LeetCode%EF%BC%89/"/>
    
    
      <category term="LeetCode" scheme="http://lovemonths.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>gcc的基本用法和gdb命令行调试</title>
    <link href="http://lovemonths.com/2019/04/29/gcc%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8Cgdb%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%B0%83%E8%AF%95/"/>
    <id>http://lovemonths.com/2019/04/29/gcc的基本用法和gdb命令行调试/</id>
    <published>2019-04-29T07:13:16.000Z</published>
    <updated>2019-04-29T07:42:11.401Z</updated>
    
    <content type="html"><![CDATA[<p>gcc  test.c</p><p>预处理：头文件替换，宏展开，去掉注释，条件编译，其他预处理命令</p><p>编译：源代码文件转换成汇编代码</p><p>汇编：汇编代码转换成二进制文件</p><p>连接：把所有的二进制文件和依赖的库合并到一起，得到可执行程序</p><p>gcc的基本用法   -&gt;a.out    -o</p><p>-g   编译的时候保留调试信息   VS  debug模式</p><p>在有些场景下，优化可能会导致程序的执行逻辑发生改变（多线程）</p><p><strong>gdb：命令行调试工具</strong></p><p> break/b : 给某个位置的代码打断点，参数可以是一个行号，也可以是一个函数名</p><p>run/r : 开始执行</p><p>print/p : 查看变量内容</p><p>continue/c : 继续执行</p><p>quit/q : 退出gdb</p><p>//info b : 查看断点信息</p><p>next/n : 单步执行（逐过程）</p><p>step/s : 单步执行 (逐语句)</p><p>backtrace/bt:查看函数的调用栈</p><p>frame/f ：切换到某个指定栈桢</p><h5 id="调试一个问题的步骤和思路？"><a href="#调试一个问题的步骤和思路？" class="headerlink" title="调试一个问题的步骤和思路？"></a>调试一个问题的步骤和思路？</h5><p>1、确认是不是bug：唯一依据产品的需求</p><p>2、定位问题，找到哪行代码引起的bug</p><p>3、分析问题的原因</p><p>4、提出方案并进行修改</p><p>5、测试（防止代码引入新的问题）</p><p>ctrl + r能够快速搜索之前敲过的命令</p><p><strong>工作中的用法：</strong></p><p>1、使用gdb调试coredump文件，coredump就是程序临终前的遗言</p><p>ulimit -a</p><p>PID</p><p>2、使用gdb attach（附加）上一个程序</p><p>工程管理工具：解决大型项目中的模块之间的依赖问题。</p><p>make命令的执行过程</p><p>1、先在当前目录中查找Makefile/makefile文件</p><p>2、找到要生成的目标（决定是否要真的生成）</p><p>3、检查依赖的文件是否都存在</p><p>4、执行生成动作的命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gcc  test.c&lt;/p&gt;
&lt;p&gt;预处理：头文件替换，宏展开，去掉注释，条件编译，其他预处理命令&lt;/p&gt;
&lt;p&gt;编译：源代码文件转换成汇编代码&lt;/p&gt;
&lt;p&gt;汇编：汇编代码转换成二进制文件&lt;/p&gt;
&lt;p&gt;连接：把所有的二进制文件和依赖的库合并到一起，得到可执行程序&lt;/p
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://lovemonths.com/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://lovemonths.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>vim的使用</title>
    <link href="http://lovemonths.com/2019/04/29/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://lovemonths.com/2019/04/29/vim的使用/</id>
    <published>2019-04-29T06:40:40.000Z</published>
    <updated>2019-04-29T07:11:42.900Z</updated>
    
    <content type="html"><![CDATA[<p>vim [文件]：打开一个文件，不存在就会创建新文件</p><p>:q   退出</p><p>x    删除光标下的字符</p><p>i     进入插入模式，光标在当前位置之前</p><p>A    进入插入模式，光标在行位</p><p>dw  从当前位置</p><p>de   从当前位置删除到单词末尾</p><p>d$   从当前位置删除到行末</p><p>dd   删除一整行</p><p>ctrl+z    切换到后台</p><p>fg <enter>切换回刚才的程序</enter></p><p>u        撤销一处更改    undo</p><p>U        撤销整行的更改</p><p>ctrl+r        redo</p><p>vim  中删除的内容都放在剪贴板（寄存器）中</p><p>p   黏贴剪贴板中的内容</p><p>r    替换光标位置的字符</p><p>c    修改类命令   删除内容的同时进入插入模式</p><p>ctrl + g显示文件状态信息</p><p>G  来到文件末尾</p><p>[number]G跳转到任意指定行</p><p>：[number] 跳转到任意指定行</p><p>gg      来到文件开头</p><p>“         回到上次的位置</p><p>/    进行字符串查找n是查找下一个，N查找上一个</p><p>%   查找到匹配的括号</p><p>:!     这是在vim外部执行一个命令</p><p>o  在当前行的下方创建一个新行，并进入插入模式</p><p>O  在当前行的上方创建一个新行，并进入插入模式</p><p>i   在当前光标的之前进入插入模式</p><p>I   在行首进行插入模式</p><p>a  是在当前光标之后进入插入模式</p><p>A  是在行末进行插入模式</p><p>R  进入替换模式</p><p>v    进入可视模式（选中一段内容）</p><p>y     复制选中的内容</p><p>p   粘贴剪贴板的内容</p><p>：set设置一些编辑器选项   </p><p>：set  monse = a启用鼠标</p><p>：set  num 启用行号</p><p>：set hlsearch高亮搜索结果</p><p>ctrl + s：xshell 冻结当前界面</p><p>ctrl+q：  解除冻结</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vim [文件]：打开一个文件，不存在就会创建新文件&lt;/p&gt;
&lt;p&gt;:q   退出&lt;/p&gt;
&lt;p&gt;x    删除光标下的字符&lt;/p&gt;
&lt;p&gt;i     进入插入模式，光标在当前位置之前&lt;/p&gt;
&lt;p&gt;A    进入插入模式，光标在行位&lt;/p&gt;
&lt;p&gt;dw  从当前位置&lt;/p
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://lovemonths.com/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://lovemonths.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux权限管理</title>
    <link href="http://lovemonths.com/2019/04/26/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://lovemonths.com/2019/04/26/Linux权限管理/</id>
    <published>2019-04-26T04:41:32.000Z</published>
    <updated>2019-04-29T06:29:41.171Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Linux下有两种用户：超级用户（root）、普通用户"><a href="#Linux下有两种用户：超级用户（root）、普通用户" class="headerlink" title="Linux下有两种用户：超级用户（root）、普通用户"></a>Linux下有两种用户：超级用户（root）、普通用户</h4><p>超级用户：在Linux上做任何事情</p><p>普通用户：在Linux上做有限的事情</p><p>超级用户的命令提示符是#，普通用户命令提示符是$</p><h3 id="Linux权限管理"><a href="#Linux权限管理" class="headerlink" title="Linux权限管理"></a>Linux权限管理</h3><p>su切换用户</p><p>任何一个文件具有的权限，针对不同的用户是不一样的，</p><p>第一组    rwx表示的是文件的拥有者的权限</p><p>第二组    rwx表示的是和文件拥有者同组的用户的权限</p><p>第三组    rwx表示的是其他用户的权限</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>d：文件夹</p><p> -：普通文件</p><p> l：软链接（类似Windows的快捷方式）</p><p> b：块设备文件（例如硬盘、光驱等）</p><p> p：管道文件</p><p> c：字符设备文件（例如屏幕等串口设备） </p><p> s：套接口文件 </p><h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>chmod -r 去掉读权限</p><p>chmod +r 加上读权限</p><p>chmod u-r 只对文件拥有者权限更改</p><p>chmod g-r 操作同组用户的权限</p><p>chmod o-r 操作其他用户的权限</p><p>chmod  777[三位八进制的权限] 修改文件权限</p><p>二进制000 110 100</p><p>八进制   0     6      4</p><p>所谓的执行权限是一个程序执行的必要条件，但是不是充要条件</p><h2 id="whereis-能够找到对应指令的可执行程序-sz可以linux文件移动到windows上，​-linux程序只能在linux执行，windows程序只能在windows执行"><a href="#whereis-能够找到对应指令的可执行程序-sz可以linux文件移动到windows上，​-linux程序只能在linux执行，windows程序只能在windows执行" class="headerlink" title="whereis   能够找到对应指令的可执行程序      sz可以linux文件移动到windows上，​ linux程序只能在linux执行，windows程序只能在windows执行"></a>whereis   能够找到对应指令的可执行程序      sz可以linux文件移动到windows上，​ linux程序只能在linux执行，windows程序只能在windows执行</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Linux下有两种用户：超级用户（root）、普通用户&quot;&gt;&lt;a href=&quot;#Linux下有两种用户：超级用户（root）、普通用户&quot; class=&quot;headerlink&quot; title=&quot;Linux下有两种用户：超级用户（root）、普通用户&quot;&gt;&lt;/a&gt;Linux
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://lovemonths.com/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://lovemonths.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++多态</title>
    <link href="http://lovemonths.com/2019/04/24/%E5%A4%9A%E6%80%81/"/>
    <id>http://lovemonths.com/2019/04/24/多态/</id>
    <published>2019-04-24T12:26:45.000Z</published>
    <updated>2019-04-29T06:30:05.857Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一.什么是多态</strong></p><p>​         按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><p><strong>二.多态的定义与实现</strong></p><p>1.定义的构成条件</p><p>1）调用函数的对象必须是指针或者引用。</p><p>2）被调用的函数必须是虚函数，且完成了虚函数的重写。</p><p><em>非多态看类型    多态看对象</em></p><p><u>什么是虚函数？</u></p><p>答：在类的成员函数前面加上virtual关键字。</p><p><u>什么是虚函数重写？</u></p><p>答：派生类中有一个跟基类的完全相同虚函数，我们就称子类的虚函数重写了基类的虚函数，完<br>全相同是指：函数名、参数、返回值都相同。另外虚函数的重写也叫作虚函数的覆盖。</p><p><strong>例子：</strong></p><p><code>class Person {</code><br><code>public:</code><br>        <code>virtual void BuyTicket() { cout &lt;&lt; &quot;买票-全价&quot; &lt;&lt; endl; }</code><br><code>};</code><br><code>class Student : public Person {</code><br><code>public:</code><br>        <code>virtual void BuyTicket() { cout &lt;&lt; &quot;买票-半价&quot; &lt;&lt; endl; }</code><br><code>};</code></p><p><u>虚函数重写的例外：协变</u></p><p>重写的虚函数的返回值可以不同，但是必须分别是基类指针和派生类指针或者基类引用和派生类引用。</p><p><strong>例子：</strong></p><p><code>class Person {</code><br><code>public:</code><br>        <code>virtual A* f() {return new A;}</code><br><code>};</code><br><code>class Student : public Person {</code><br><code>public:</code><br>        <code>virtual B* f() {return new B;}</code><br><code>};</code></p><p><strong>析构函数的重写问题</strong></p><p>​         基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor，这也说明的基类的析构函数最好写成虚函数。</p><p><strong>例子：</strong></p><p><code>class Person {</code><br><code>public:</code><br>         <code>virtual ~Person() {cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;}</code><br><code>};</code><br><code>class Student : public Person {</code><br><code>public:</code><br>      <code>virtual ~Student() { cout &lt;&lt; &quot;~Student()&quot; &lt;&lt; endl; }</code><br><code>};</code><br><code>// 只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函数，才能构成多态，才能保证p1和p2指向的对象正确的调用析构函数。</code><br><code>int main()</code><br><code>{</code><br>   <code>Person* p1 = new Person;</code><br>  <code>Person* p2 = new Student;</code><br>   <code>delete p1;</code><br>   <code>delete p2;</code><br>   <code>return 0;</code><br><code>}</code></p><p><strong>接口继承和实现继承</strong></p><p>​    普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以如果不实现多态，不要把函数定义成虚函数。</p><p>2.重载、覆盖（重写）、隐藏（重定义）的对比</p><p><strong>重载</strong></p><p>1.两个函数在同一个作用域</p><p>2.函数名/参数相同</p><p><strong>重写（覆盖）</strong></p><p>1.两个函数分别在基类和派生类</p><p>2.函数名/参数/返回值都必须相同（协变例外）</p><p>3.两个函数必须是虚函数</p><p><strong>重定义（隐藏）</strong></p><p>1.两个函数分别在基类和派生类作用域</p><p>2.函数名相同</p><p>3.两个基类和派生类的同名函数不构成重写就是重定义</p><p><strong>三.抽象类</strong></p><p>​        在虚函数的后面写上 =0 ，则这个函数为纯虚函数。<strong>包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。</strong>派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。</p><p><code>class Car</code><br><code>{</code><br><code>public:</code><br>      <code>virtual void Drive() = 0;</code><br><code>};</code><br><code>class Benz :public Car</code><br><code>{</code><br><code>public:</code><br>      <code>virtual void Drive()</code><br>      <code>{</code><br>           <code>cout &lt;&lt; &quot;Benz-舒适&quot; &lt;&lt; endl;</code><br>       <code>}</code><br><code>};</code><br><code>class BMW :public Car</code><br><code>{</code><br><code>public:</code><br>         <code>virtual void Drive()</code><br>         <code>{</code><br>             <code>cout &lt;&lt; &quot;BMW-操控&quot; &lt;&lt; endl;</code><br>          <code>}</code><br><code>};</code><br><code>void Test()</code><br><code>{</code><br>        <code>Car* pBenz = new Benz;</code><br>         <code>pBenz-&gt;Drive();</code><br>        <code>Car* pBMW = new BMW;</code><br>        <code>pBMW-&gt;Drive();</code><br><code>}</code></p><p><strong>C++11 override 和 final</strong></p><p>​        建议多使用纯虚函数+ override的方式来强制重写虚函数，因为虚函数的意义就是实现多态，如果没有重写，虚函数就没有意义。</p><p>1.final修饰基类的虚函数不能被派生类重写</p><p>2.override修饰派生类的虚函数完成重写，如果没有重写会编译报错</p><p><strong>多态的原理</strong></p><p>1.虚基表</p><p><code>class Base</code><br><code>{</code><br><code>public:</code><br><code>virtual void Func1()</code><br><code>{</code><br><code>cout &lt;&lt; &quot;Func1()&quot; &lt;&lt; endl;</code><br><code>}</code><br><code>private:</code><br><code>int _b = 1;</code><br><code>};</code></p><p>计算sizeof(Base)为多少？</p><p>除了_b成员，还多一个__vfptr放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关)，对象中的这个指针我们叫做虚函数表指针(v代表virtual，f代表function)。所以为8bytes。</p><p><code>class Base</code><br><code>{</code><br><code>public:</code><br>    <code>virtual void Func1()</code><br>    <code>{</code><br>        <code>cout &lt;&lt; &quot;Base::Func1()&quot; &lt;&lt; endl;</code><br>    <code>}</code><br>    <code>virtual void Func2()</code><br>    <code>{</code><br>        <code>cout &lt;&lt; &quot;Base::Func2()&quot; &lt;&lt; endl;</code><br>    <code>}</code><br>    <code>void Func3()</code><br>    <code>{</code><br>        <code>cout &lt;&lt; &quot;Base::Func3()&quot; &lt;&lt; endl;</code><br>    <code>}</code><br><code>private:</code><br>    <code>int _b = 1;</code><br><code>};</code><br><code>class Derive : public Base</code><br><code>{</code><br><code>public:</code><br>    <code>virtual void Func1()</code><br>    <code>{</code><br>        <code>cout &lt;&lt; &quot;Derive::Func1()&quot; &lt;&lt; endl;</code><br>    <code>}</code><br><code>private:</code><br>    <code>int _d = 2;</code><br><code>};</code></p><p><code>int main()</code><br><code>{</code><br>    <code>Base b;</code><br>    <code>Derive d;</code></p><p>​         <code>return 0;</code></p><p><code>}</code></p><p>通过测试发现：</p><ol><li><p>派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员。</p></li><li><p>基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖。重写是语法的叫法，覆盖是原理层的叫法。</p></li><li><p>另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表。</p></li><li><p>虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。</p></li><li><p>总结一下派生类的虚表生成：a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。</p></li><li><p>虚函数存在哪的？虚表存在哪的？</p><p>答：虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中。另外对象中存的不是虚表，存的是虚表指针，vs中虚表是存在代码段的。</p></li></ol><h3 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h3><p><img src="https://wx4.sinaimg.cn/mw690/006v1ap6ly1g2e05xknpvj30mj08eju5.jpg" alt="多态原理"></p><p>​           1.p中存的是mike对象的指针，将p移动到eax中 </p><p>​           2.[eax]就是取eax值指向的内容，这里相当于把mike对象头4个字节(虚表指针)移动到了edx</p><p>​           3.[edx]就是取edx值指向的内容，这里相当于把虚表中的头4字节存的虚函数指针移动到了eax</p><p>​           4.call eax中存虚函数的指针。这里可以看出满足多态的调用，不是在编译时确定的，是运行起   </p><p>​            来以后到对象中取到的。</p><h5 id="如何实现多态？"><a href="#如何实现多态？" class="headerlink" title="如何实现多态？"></a>如何实现多态？</h5><p> 多态的对象模型：只要类中有虚函数，对象模型就会放一个虚表指针，虚表指针指向虚表，虚表本质上为虚函数指针数组，虚表在vs下存在代码段</p><p>1.本质上是通过虚表实现：程序在运行的时候，根据引用或者指针指向的对象，访问对象模型中虚表指针，获取虚表中对应位置的函数指针，调用对应的函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一.什么是多态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​         按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="C++学习" scheme="http://lovemonths.com/categories/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://lovemonths.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本操作指令</title>
    <link href="http://lovemonths.com/2019/04/23/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/"/>
    <id>http://lovemonths.com/2019/04/23/linux基本操作指令/</id>
    <published>2019-04-23T11:50:10.000Z</published>
    <updated>2019-04-29T06:29:11.806Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一. 目录操作命令</strong></p><p><strong>1.列目录内容（ls）</strong></p><p>1）功能和用法</p><p>ls（list）的功能是列指定目录的内容，并将输出按某种方式排序。若不指定目录，则默认为当前目录。</p><p>​                 <code>ls [options][files]</code></p><p>2)  参数说明</p><p>ls的部分命令参数如下表：</p><ul><li>-a 列出目录下的所有文件，包括以 . 开头的隐含文件。 </li><li>-d 将目录象文件一样显示，而不是显示其下的文件。 如：ls –d 指定目录 </li><li>-i 输出文件的 i 节点的索引信息。 如 ls –ai 指定文件 </li><li>-k 以 k 字节的形式表示文件的大小。ls –alk 指定文件 </li><li>-l 列出文件的详细信息。 </li><li>-n 用数字的 UID,GID 代替名称。</li><li>-F 在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表 示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)。（目录类型识别） </li><li>-r 对目录反向排序。 </li><li>-t 以时间排序。 </li><li>-s 在l文件名后输出该文件的大小。（大小排序，如何找到目录下大的文件） </li><li>-1 一行只输出一个文件。 </li></ul><p>3)  举例</p><p>​                <code>ls -1</code></p><p><strong>2.建立目录（mkdir）</strong></p><p>1）功能与用法</p><p>​        mkdir（make directory)命令的功能是创建子目录，一次可以创建一个或多个子目录，还可以一次去创建包括全部父目录和子目录在内的一个完整的目录结构，它的使用受权限的制约。mkdir的用法为：</p><p>​          <code>mkdir [-p][-m MODE] dirs</code></p><p>2)   参数说明</p><p>​      -p：如果要创建的目录存在也不报错，则必要时可一同创建父目录。-m，–mode=MODE：按照权限MODE创建子目录。</p><p>3）举例</p><p>​       <code>$mkdir  temp        #在工作目录下，建立一个名为temp的子目录</code></p><p>​       <code>$mkdir temp1 temp2 temp3     #一次创建多个目录</code></p><p>​       <code>$mkdir  -p  temp4/child    #在temp4下创建子目录child，没有-p参数，父目录如果不存在，</code></p><p>​       <code>#将导致创建失败</code></p><p><strong>3.改变工作目录</strong></p><p>​       cd（change directory)命令是改变用户的当前工作目录。它的使用受权限制约，用户必须对要进入的目录有执行权。其用法为：</p><p>​                  <code>cd  [dir]</code></p><p><strong>4.显示当前目录（pwd）</strong></p><p>​    pwd（print working directory)命令的功能是显示当前目录。其用法为：</p><p>​                <code>pwd[-P][-L]</code></p><p>选项-P,-L分别显示当前目录的物理和逻辑位置，默认为后者。</p><p><strong>二. 文件操作基本命令</strong></p><p><strong>1.显示文件的内容或合并文件（cat）</strong></p><p>1) 功能和用法</p><p>​        cat（catenate）命令用来把文件内容显示到屏幕上，也可以同时显示多个文件。当不带参数运行cat时使用标准输入。使用cat通过I/O重定向的方法将多个文件的显示内容改到某个文件中，从而实现文件合并。cat的用法为：</p><p>​            <code>cat [options][files]</code></p><p>2) 举例</p><p>​            <code>$cat -n test.txt   #显示文件test.txt的内容，并为所有行添加行号</code></p><p><strong>2.浏览文件(less)</strong></p><p>​    less 命令和more一样都有分页处理命令，但less比more功能更强大。它可以使用PgUp和PgUn翻页，使用HOME和END直接跳到文件开始或结尾。</p><p>​     less命令是许多程序的（如man）等使用的默认的分页处理命令。如果想阅读压缩文件，它会调用less命令来处理。</p><p><strong>3.文件移动或更名（mv）</strong></p><p>1）功能和用法</p><p>mv（move）命令的功能是文件位置移动或更名。其用法为：</p><p>​         mv [options]  source  dest</p><p>​         mv [options]  source … directory</p><p>​         第一种用法是将源文件移动到目的文件，可用于文件移动或更名；第二种用法是将一批文件移动到某个目录directory。mv命令是有副作用的，但可以通过备份的方式避免。</p><p>​         mv 至少需要两个参数，一个用于源文件，另一个是目标文件或位置，若目标为当前目录可用</p><p>“ . ”表示，但不能省略。</p><p>2）举例</p><p>​       <code>$mv file1 file2        #若file2存在，则在不使用备份时将被覆盖</code></p><p>​       <code>$mv myfile /tmp/tmpf    #将myfile移动至/tmp/tmpf 下或更名为/tmp/tmpf</code></p><p>​       <code>$mv file1 file2 mydir       #将文件file1，file2移动到目录mydir下</code></p><p>​       <code>$mv  -bf  -V&quot;t&quot; file1 file2 mydir #以备份方式移动文件</code></p><p><strong>4.文件和目录复制（cp）</strong></p><p>1）功能和用法</p><p>​        cp（copy）命令的功能是文件目录复制。不能复制设备文件，但却可复制设备文件的内容以构造映像。其用法为：</p><p>​         <code>cp [options]  source  dest</code></p><p>​         <code>cp [options]  source ... directory</code></p><p>​         第一种用法是将源文件移动到目的文；第二种用法是将一批文件复制到某个目录directory。cp命令也有副作用的，但可以通过备份的方式避免。</p><p>​         cp 至少需要两个参数，一个用于源文件，另一个是目标文件或位置，若目标为当前目录可用</p><p>“ . ”表示，但不能省略。</p><p>2）举例</p><p>​           <code>$cp file1 file2       #将文件file1复制到file2，默认采用交互方式</code></p><p>​           <code>$cp /tmp/myp.c .    #将文件/tmp/myp.c 复制到当前目录</code></p><p>​           <code>$cp  file1 /tmp/file2 #将文件复制到/tmp并更名为file2</code></p><p>​           <code>$cp -rp file1 file2 #将文件file复制到目录file2中，且保持原有属性</code> </p><p><strong>5.修改文件存取时间或创建空文件（touch）</strong></p><p>1）功能和用法</p><p>​       touch命令的功能有两点：一是建立空文件；二是更新文件的存取时间。默认时，将文件属性中的3个时间都修改为系统的当前时间。若指定文件不存在，则创建空文件。</p><p>2）举例</p><p>​          <code>$touch myfile          #将文件的访问时间等改为当前时间，若不存在则创建</code></p><p>​          <code>$touch -a -t 200601020030 myfile yourfile  #修改文件的存取时间</code></p><p>​          <code>$touch -m -t 200706050403 myfile  #修改文件的修改时间</code></p><p><strong>6.rmdir指令 &amp;&amp; rm 指令</strong></p><p>rmdir是一个与mkdir相对应的命令。mkdir是建立目录，而rmdir是删除命令。 </p><p>1)rm命令的使用方式：</p><p>​          <code>rm [options] files</code></p><p>2)举例</p><p>​               <code>$rm -rf  file       #强制删除</code></p><p>​               <code>$rm -r file         #递归删除</code></p><p><strong>7.man指令</strong></p><p>查手册指令</p><p>举例：</p><p>​                <code>$ man  open</code></p><p><strong>8.清屏指令</strong></p><p>​       clear  或者  CTRL  L</p><p><strong>9.字符串或变量输出指令（echo）</strong></p><p>1）功能与用法</p><p>​      echo命令将其命令行参数中的字符串或变量的值写到标准输出。默认情况下，每个echo命令执行完毕后会产生一个换行符，如果不带参数执行此命令，将输出一个空行。echo命令的使用方式为：</p><p>​               <code>echo [options] string ...</code></p><p>2)举例</p><p>​            <code>$echo &quot;my name is Bill Joy&quot;    #以上命令的输出在同一行上</code></p><p>​            <code>$echo -n &quot;my name is Bill Joy&quot;   #不处理换行</code></p><p><strong>10.日期与时间管理指令</strong></p><p>1）功能与用法</p><p>date命令的用法为：</p><p>​      <code>date [options][+FORMAT]</code></p><p>​       <code>date[-u|--utc|--universal][MMDDhhmm][[CC]YY][.ss]</code></p><p>2) 举例</p><p>​       <code>$date     #以默认格式显示系统的当前时间</code></p><p>​       <code>$date 05311010  #设置系统的当前时间为当年5月31日10:10:00</code></p><p>​       <code>$date -s  &quot;+2 mintes&quot;    #将系统的时间前提两分</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一. 目录操作命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.列目录内容（ls）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）功能和用法&lt;/p&gt;
&lt;p&gt;ls（list）的功能是列指定目录的内容，并将输出按某种方式排序。若不指定目录，则默认为当前目录。&lt;/p
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://lovemonths.com/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://lovemonths.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++继承</title>
    <link href="http://lovemonths.com/2019/04/23/%E7%BB%A7%E6%89%BF/"/>
    <id>http://lovemonths.com/2019/04/23/继承/</id>
    <published>2019-04-23T09:12:37.000Z</published>
    <updated>2019-04-29T06:30:22.280Z</updated>
    
    <content type="html"><![CDATA[<p>﻿<strong>一.基本概念：</strong><br>1.一个类可以继承另一个类，继承的类称为派生类（子类）、被继承的类称之为基类（父类）。<br>2.子类继承了父类所有成员，除了构造函数和赋值运算符重载。<br>3.子类继承父类后，子类的成员分为两部分（1）继承之父类的部分base part（2）子类自己扩展的部分 appendent part<br>4.子类继承父类后，子类依然不能访问父类的私有成员，子类只能通过继承之父类的公有成员来访问父类的私有成员。<br>5.子类可以实现与父类成员函数原型相同的函数称为重写（覆盖）overwrite。<br>6.子类调子类的，父类不能调子类的，子类可以调用被覆盖的父类版本的函数，使用子类对象名.父类名：：函数名，比如：s.farther::print();<br>7.子类通过父类的私有成员的两种方式：<br>（1）通过父类的公有成员函数<br>（2）将私有成员改成保护成员protected<br><strong>二.继承的使用</strong><br>1.继承使用的两种情况：<br>（1）类之间有自然的继承关系，一个类是另一个类的特例，比如：一个学生是一个人。<br>（2）实现代码复用，一个类需要使用一个类的成员时。<br>2.继承的好处：<br>（1）代码复用<br>（2）使代码修改更容易<br>3.两个类之间的交互关系<br>（1）组合类 一个类中有另一个类的对象 has-a<br>（2）继承类 一个类是另一个类的特例        is-a<br><strong>三.c++的三种继承</strong><br>（1）公有继承（public）<br>公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。<br>（2）保护继承（protected）<br>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。<br>（3）私有继承（private）<br>私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。<br><strong>总结：</strong>private能够对外部和子类保密，即除了成员所在的类本身可以访问之外，别的都不能直接访问。protected能够对外部保密，但允许子类直接访问这些成员。</p><p><code>class Base    //父类</code><br>  <code>{</code><br>    <code>private:</code><br>         <code>int _priB;</code><br>     <code>protected:</code><br>         <code>int _proB;</code><br>     <code>public:</code><br>        <code>int _pubB;</code><br>  <code>} ;</code><br> <code>class Derived: public Base    //子类，继承自base,继承类型为公有继承</code><br> <code>{</code><br>    <code>private:</code><br>       <code>int _d_pri;</code><br>    <code>protected:</code><br>      <code>int _d_pro;</code><br>    <code>public:</code><br>        <code>void funct()</code><br>     <code>{</code><br>       <code>int d;</code><br>         <code>d=_priB;       //error：基类中私有成员在派生类中是不可见的</code><br>         <code>d=_proB;       //ok： 基类的保护成员在派生类中为保护成员</code><br>         <code>d=_pubB;       //ok： 基类的公共成员在派生类中为公共成员</code><br>     <code>}</code><br>       <code>int _d_pub;</code><br> <code>} ;</code></p><p>总结：（1）. public继承是一个接口继承，保持is-a原则，每个父类可用的成员对子类也可用， 因为每个子类对象也都是一个父类对象。</p><p> <code>class C :private Base    //基类Base的派生类C（私有继承）</code><br> <code>{</code><br> <code>public:</code><br>     <code>void funct()</code><br>     <code>{</code><br>         <code>int c;</code><br>         <code>c=_priB;      //error：基类中私有成员在派生类中是不可见的</code><br>         <code>c=_proB;      //ok：基类的保护成员在派生类中为私有成员</code><br>         <code>c=_pubB;      //ok：基类的公共成员在派生类中为私有成员</code><br>     <code>}</code><br> <code>};</code><br> <code>class E :protected Base   //基类Base的派生类E（保护继承）</code><br> <code>{</code><br> <code>public:</code><br>     <code>void funct()</code><br>     <code>{</code><br>         <code>int e ;</code><br>         <code>e=_priB;    //error：基类中私有成员在派生类中是不可见的</code><br>         <code>e=_proB;    //ok：基类的保护成员在派生类中为保护成员</code><br>         <code>e=_pubB;    //ok：基类的公共成员在派生类中为保护成员</code><br>     <code>}</code><br> <code>};</code></p><p>总结：<br>（2）. 基类的private成员 在派生类中是不能被访问的， 如果基类成员 不想在类外直接被访问， 但需要 在派生类中能访问， 就定义为protected。 可以看出保护成员 限定符是因继承才出现的。<br>（3）. protected/private继承是一个实现继承， 基类的部分成员 并非完全成为子类接口 的一部分， 是 has-a 的关系原则， 所以非特殊情况下不会使用这两种继承关系， 在绝大多数的场景下使用的 都是公有继承。 私有继承以为这is-implemented-in-terms-of(是根据……实现的) 。 通常比组合(composition) 更低级， 但当一个派生类需要访问 基类保护成员 或需要重定义基类的虚函数时它就是合理的。</p><p> <code>int main()</code><br> <code>{</code><br>     <code>int a;</code><br>     <code>D d;</code><br>     <code>a=D._priB;     //error：公有继承基类中私有成员在派生类中是不可见的,对对象不可见</code><br>     <code>a=D._proB;           //error：公有继承基类的保护成员在派生类中为保护成员，对对象不可见</code><br>     <code>a=D._pubB;     //ok：公有继承基类的公共成员在派生类中为公共成员，对对象可见</code><br>     <code>C c;</code><br>     <code>a=c._priB;    //error：私有继承基类中私有成员在派生类中是不可见的, 对对象不可见</code><br>     <code>a=c._proB;    //error：私有继承基类的保护成员在派生类中为私有成员，对对象不可见</code><br>     <code>a=c._pubB;    //error：私有继承基类的公共成员在派生类中为私有成员，对对象不可见</code><br>     <code>E e;</code><br>     <code>a=e._priB;    //error：保护继承基类中私有成员在派生类中是不可见的, 对对象不可见</code><br>     <code>a=e._proB;    //error：保护继承基类的保护成员在派生类中为保护成员，对对象不可见</code><br>     <code>a=e._pubB;    //error：保护继承基类的公共成员在派生类中为保护成员，对对象不可见</code></p><p>​     <code>return 0;</code><br> <code>}</code></p><p>（4）. 不管是哪种继承方式， 在派生类内部都可以访问基类的公有成员和保护成员 ， 基类的私有成员存在但是在子类中不可见（ 不能访问） 。<br>（5）. 使用关键字class时默认的继承方式是private， 使用struct时默认的继承方式是public， 不过最好显式的写出继承方式。<br>（6）. 在实际运用中一般使用都是public继承， 极少场景下才会使用protetced/private继承。</p><p>在struct继承中，如果没有显式给出继承类型，则默认的为public继承；在class继承中，如果没有显式给出继承类型，则默认的为private继承；<br><strong>四.派生类的默认成员函数</strong><br>1.构造与析构的调用关系<br>先看一段代码：</p><p><code>class Person</code><br><code>{</code><br><code>public:</code><br>    <code>Person(const char* name = &quot;hello&quot;)</code><br>        <code>: _name(name)</code><br>    <code>{</code><br>             <code>cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</code><br>    <code>}</code><br>    <code>~Person() // ~destructor</code><br>    <code>{</code><br>        <code>cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</code><br>    <code>}</code></p><p><code>protected:</code><br>    <code>string _name; // 姓名</code><br><code>};</code><br><code>class Student : public Person</code><br><code>{</code><br><code>public:</code><br><code>Student(const char* name = &quot;helo&quot;)</code><br>        <code>:_id(10)</code><br>        <code>,Person(name)</code><br>    <code>{</code><br>             <code>cout &lt;&lt; &quot;Student(const char* name)&quot; &lt;&lt; endl;</code><br>    <code>}</code><br><code>~Student()  // ~destructor  同名隐藏，编译器底层对析构函数的名字做了修改，为了使用多态</code><br>    <code>{</code><br>        <code>cout &lt;&lt; &quot;~Student()&quot; &lt;&lt; endl;</code><br>        <code>//Person::~Person();</code><br>    <code>}</code><br><code>private:</code><br>    <code>int _id;</code><br><code>};</code><br><code>int main()</code><br><code>{</code><br>    <code>Student s;</code><br>    <code>return 0；</code><br><code>}</code></p><p>结果如下：<br>Person()<br>Student(const char* name)<br>~Student()<br>~Person()</p><p><em>分析：基类是派生类的一部分，创建派生类对象时必须调用派生类构造函数，而派生类构造函数必须使用基类的构造函数。程序首先创建基类对象，所以基类对象在程序进入派生类构造函数之前被创建。实际上C++使用成员初始化列表语法来完成这项工作，即Person()相当于在函数Student()的初始化列表中被使用，如果不调用基类构造函数，程序将使用默认的基类构造函数。在执行完Person()的函数体之后，继承的数据成员被初始化，执行Student()函数体初始化新增的数据成员。析构对象时，先调用派生类的析构函数，执行完函数体析构完新增部分之后，使用基类的析构函数析构继承自基类的部分。</em></p><p><strong>总结：创建派生类对象时程序调用派生类构造函数，然后在初始化列表部分调用基类构造函数初始化继承的数据成员，而派生类构造函数主要初始化新增的数据成员。派生类总是调用一个基类构造函数。可以使用初始化列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将先调用派生类析构函数，在函数体执行完之后调用基类析构函数。（可以看到，继承的数据成员生命周期长， 新增的数据成员生命周期短。）</strong><br>2.拷贝构造函数<br>使用情况：<br>1.将新的对象初始化为一个同类对象<br>2.按值将对象传递给函数<br>3.函数按值返回对象<br>4.编译器生成临时对象<br><strong>注意：如果基类中没有指针成员，可以使用浅拷贝，如果有指针成员，必须要进行显式定义拷贝构造函数，即进行深拷贝。不然会造成同一块内存空间被析构两次的问题。</strong><br>3.赋值操作符<br>        默认的赋值操作符用于处理同类对象之间的赋值，赋值不是初始化，如果语句创建新的对象，则使用初始化，如果语句修改已有对象的值，则为赋值。 赋值运算符是不能被继承的，原因很简单。派生类继承的方法的特征与基类完全相同，但赋值操作符的特征随类而异，因为它包含一个类型为其所属类的形参。<br> <strong>注意：赋值运算和拷贝构造是不同的，赋值是赋值给一个已有对象，拷贝构造是构造一个全新的对象</strong><br> 将派生类赋值给基类对象：<br> [<img src="https://img-blog.csdnimg.cn/2019042316362144.png" alt="在这里插入图片描述"><br>基类对象赋值给派生类对象：<br><img src="https://img-blog.csdnimg.cn/20190423163845421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbl9zaGlfbGVp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：<br><strong>是否可以将基类对象赋给派生类对象，答案是也许。如果派生类包含了转换构造函数，即对基类对象转换为派生类对象进行了定义，则可以将基类对象赋给派生对象。</strong><br>派生类对象可以赋给基类对象。<br><strong>五.c++作用域与重定义，赋值兼容规则</strong><br>1.作用域与重定义（同名隐藏）<br>当我们在派生类中定义一个同名函数的时候，编译器是将同名函数隐藏了，不管参数表是否相同。即不会构成函数重载，直接将基类函数覆盖。<br>那问什么构不成函数重载呢？<br><strong>一定要注意，函数重载的条件是在同一个作用域中才会构成函数重载，而派生类和基类是两个类域，一定不会构成函数重载的。</strong><br>2.继承与转换——赋值兼容规则（public继承为例）<br>基类和派生类的特殊关系：<br>1.派生类对象可以赋值给基类对象 ;基类对象不能赋值给派生类。<br>2.基类指针可以在不进行显示类型转换的情况下指向派生类对象 。<br>3.基类引用可以在不进行显示类型转换的情况下引用派生类对象，但是基类指针或引用只能用于调用基类的方法，不能用基类指针或引用调用派生类的成员及方法。<br><strong>C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是个例外。但是这个例外是单向的，即仅仅不可以将基类对象和地址赋给派生类引用和指针。如果允许基类引用隐式的引用派生类对象，则可以使用基类引用为派生类对象调用基类的方法，因为派生类继承了基类的方法，所以这样不会出现问题。但是如果可以将基类对象赋给派生类引用，那么派生类引用能够为积类对象调用派生类方法，这样做会出现问题，例如：用基类对象调用派生类中新增的方法，是没有意义的，因为基类对象中根本没有派生类的新增方法。</strong><br>3.友员与继承<br>友元关系不能继承， 也就是说基类友元不能访问子类私有和保护成员 。友元只是能访问指定类的私有和保护成员的自定义函数，不是被指定类的成员，自然不能继承。<br><strong>应该注意：</strong><br>(1) 友元关系不能被继承。<br>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。<br>(3)友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明<br>(4)友元可以访问类的私有成员。<br>(5)友元只能出现在类定义内部，友元声明可以在类中的任何地方，一般放在类定义的开始或结尾。<br>(6)友元可以是普通的非成员函数，或前面定义的其他类的成员函数，或整个类。<br>(7)类必须将重载函数集中每一个希望设为友元的函数都声明为友元。<br>(8)友元关系不能继承，基类的友元对派生类的成员没有特殊的访问权限。如果基类被授予友元关系，则只有基类具有特殊的访问权限。该基类的派生类不能访问授予友元关系的类。<br><strong>4.继承与静态成员</strong><br>        基类定义了 static成员 ， 则整个继承体系里面只 有一个这样的成员 。 无论派生出多少个子类， 都只有 一个static成员 实例。父类的static变量和函数在派生类中依然可用，但是受访问性控制（比如，父类的private域中的就不可访问）。而且对static变量来说，派生类和父类中的static变量是共用空间的，这点在利用static变量进行引用计数的时候要特别注意。派生类的friend函数可以访问派生类本身的一切变量，包括从父类继承下来的protected域中的变量。但是对父类来说，他并不是friend的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿&lt;strong&gt;一.基本概念：&lt;/strong&gt;&lt;br&gt;1.一个类可以继承另一个类，继承的类称为派生类（子类）、被继承的类称之为基类（父类）。&lt;br&gt;2.子类继承了父类所有成员，除了构造函数和赋值运算符重载。&lt;br&gt;3.子类继承父类后，子类的成员分为两部分（1）继承之父类
      
    
    </summary>
    
      <category term="C++学习" scheme="http://lovemonths.com/categories/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://lovemonths.com/tags/C/"/>
    
  </entry>
  
</feed>
