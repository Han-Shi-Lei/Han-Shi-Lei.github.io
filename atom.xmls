<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lovemonths</title>
  
  
  <link href="/atom.xmls" rel="self"/>
  
  <link href="http://lovemonths.com/"/>
  <updated>2019-04-23T09:14:46.610Z</updated>
  <id>http://lovemonths.com/</id>
  
  <author>
    <name>������</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++继承</title>
    <link href="http://lovemonths.com/2019/04/23/%E7%BB%A7%E6%89%BF/"/>
    <id>http://lovemonths.com/2019/04/23/继承/</id>
    <published>2019-04-23T09:12:37.000Z</published>
    <updated>2019-04-23T09:14:46.610Z</updated>
    
    <content type="html"><![CDATA[<p>﻿<strong>一.基本概念：</strong><br>1.一个类可以继承另一个类，继承的类称为派生类（子类）、被继承的类称之为基类（父类）。<br>2.子类继承了父类所有成员，除了构造函数和赋值运算符重载。<br>3.子类继承父类后，子类的成员分为两部分（1）继承之父类的部分base part（2）子类自己扩展的部分 appendent part<br>4.子类继承父类后，子类依然不能访问父类的私有成员，子类只能通过继承之父类的公有成员来访问父类的私有成员。<br>5.子类可以实现与父类成员函数原型相同的函数称为重写（覆盖）overwrite。<br>6.子类调子类的，父类不能调子类的，子类可以调用被覆盖的父类版本的函数，使用子类对象名.父类名：：函数名，比如：s.farther::print();<br>7.子类通过父类的私有成员的两种方式：<br>（1）通过父类的公有成员函数<br>（2）将私有成员改成保护成员protected<br><strong>二.继承的使用</strong><br>1.继承使用的两种情况：<br>（1）类之间有自然的继承关系，一个类是另一个类的特例，比如：一个学生是一个人。<br>（2）实现代码复用，一个类需要使用一个类的成员时。<br>2.继承的好处：<br>（1）代码复用<br>（2）使代码修改更容易<br>3.两个类之间的交互关系<br>（1）组合类 一个类中有另一个类的对象 has-a<br>（2）继承类 一个类是另一个类的特例        is-a<br><strong>三.c++的三种继承</strong><br>（1）公有继承（public）<br>公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。<br>（2）保护继承（protected）<br>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。<br>（3）私有继承（private）<br>私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。<br><strong>总结：</strong>private能够对外部和子类保密，即除了成员所在的类本身可以访问之外，别的都不能直接访问。protected能够对外部保密，但允许子类直接访问这些成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class Base    //父类</span><br><span class="line">  &#123;</span><br><span class="line">    private: </span><br><span class="line">         int _priB;</span><br><span class="line">     protected:</span><br><span class="line">         int _proB;</span><br><span class="line">     public:</span><br><span class="line">        int _pubB;</span><br><span class="line">  &#125; ;</span><br><span class="line"> class Derived: public Base    //子类，继承自base,继承类型为公有继承</span><br><span class="line"> &#123;</span><br><span class="line">    private:</span><br><span class="line">       int _d_pri;</span><br><span class="line">    protected:</span><br><span class="line">       int _d_pro;</span><br><span class="line">    public:</span><br><span class="line">        void funct()</span><br><span class="line">     &#123;</span><br><span class="line">         int d;</span><br><span class="line">         d=_priB;       //error：基类中私有成员在派生类中是不可见的</span><br><span class="line">         d=_proB;       //ok： 基类的保护成员在派生类中为保护成员</span><br><span class="line">         d=_pubB;       //ok： 基类的公共成员在派生类中为公共成员</span><br><span class="line">     &#125;</span><br><span class="line">       int _d_pub;</span><br><span class="line"> &#125; ;</span><br><span class="line">总结：（1）. public继承是一个接口继承，保持is-a原则，每个父类可用的成员对子类也可用， 因为每个子类对象也都是一个父类对象。</span><br><span class="line"> class C :private Base    //基类Base的派生类C（私有继承）</span><br><span class="line"> &#123;</span><br><span class="line"> public:</span><br><span class="line">     void funct()</span><br><span class="line">     &#123;</span><br><span class="line">         int c;</span><br><span class="line">         c=_priB;      //error：基类中私有成员在派生类中是不可见的</span><br><span class="line">         c=_proB;      //ok：基类的保护成员在派生类中为私有成员</span><br><span class="line">         c=_pubB;      //ok：基类的公共成员在派生类中为私有成员</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> class E :protected Base   //基类Base的派生类E（保护继承）</span><br><span class="line"> &#123;</span><br><span class="line"> public:</span><br><span class="line">     void funct()</span><br><span class="line">     &#123;</span><br><span class="line">         int e ;</span><br><span class="line">         e=_priB;    //error：基类中私有成员在派生类中是不可见的</span><br><span class="line">         e=_proB;    //ok：基类的保护成员在派生类中为保护成员</span><br><span class="line">         e=_pubB;    //ok：基类的公共成员在派生类中为保护成员</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">总结：</span><br><span class="line">（2）. 基类的private成员 在派生类中是不能被访问的， 如果基类成员 不想在类外直接被访问， 但需要 在派生类中能访问， 就定义为protected。 可以看出保护成员 限定符是因继承才出现的。</span><br><span class="line">（3）. protected/private继承是一个实现继承， 基类的部分成员 并非完全成为子类接口 的一部分， 是 has-a 的关系原则， 所以非特殊情况下不会使用这两种继承关系， 在绝大多数的场景下使用的 都是公有继承。 私有继承以为这is-implemented-in-terms-of(是根据……实现的) 。 通常比组合(composition) 更低级， 但当一个派生类需要访问 基类保护成员 或需要重定义基类的虚函数时它就是合理的。</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     int a; </span><br><span class="line">     D d;</span><br><span class="line">     a=D._priB;     //error：公有继承基类中私有成员在派生类中是不可见的,对对象不可见     </span><br><span class="line">     a=D._proB;           //error：公有继承基类的保护成员在派生类中为保护成员，对对象不可见</span><br><span class="line">     a=D._pubB;     //ok：公有继承基类的公共成员在派生类中为公共成员，对对象可见</span><br><span class="line">     C c;</span><br><span class="line">     a=c._priB;    //error：私有继承基类中私有成员在派生类中是不可见的, 对对象不可见</span><br><span class="line">     a=c._proB;    //error：私有继承基类的保护成员在派生类中为私有成员，对对象不可见</span><br><span class="line">     a=c._pubB;    //error：私有继承基类的公共成员在派生类中为私有成员，对对象不可见</span><br><span class="line">     E e;</span><br><span class="line">     a=e._priB;    //error：保护继承基类中私有成员在派生类中是不可见的, 对对象不可见</span><br><span class="line">     a=e._proB;    //error：保护继承基类的保护成员在派生类中为保护成员，对对象不可见   </span><br><span class="line">     a=e._pubB;    //error：保护继承基类的公共成员在派生类中为保护成员，对对象不可见</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">（4）. 不管是哪种继承方式， 在派生类内部都可以访问基类的公有成员和保护成员 ， 基类的私有成员存在但是在子类中不可见（ 不能访问） 。</span><br><span class="line">（5）. 使用关键字class时默认的继承方式是private， 使用struct时默认的继承方式是public， 不过最好显式的写出继承方式。</span><br><span class="line">（6）. 在实际运用中一般使用都是public继承， 极少场景下才会使用protetced/private继承。</span><br></pre></td></tr></table></figure><p>在struct继承中，如果没有显式给出继承类型，则默认的为public继承；在class继承中，如果没有显式给出继承类型，则默认的为private继承；<br><strong>四.派生类的默认成员函数</strong><br>1.构造与析构的调用关系<br>先看一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(const char* name = &quot;hello&quot;)</span><br><span class="line">: _name(name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Person() // ~destructor</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">string _name; // 姓名</span><br><span class="line">&#125;;</span><br><span class="line">class Student : public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Student(const char* name = &quot;helo&quot;)</span><br><span class="line">:_id(10)</span><br><span class="line">,Person(name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Student(const char* name)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Student()  // ~destructor  同名隐藏，编译器底层对析构函数的名字做了修改，为了使用多态</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;~Student()&quot; &lt;&lt; endl;</span><br><span class="line">//Person::~Person();</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int _id;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Student s;</span><br><span class="line">return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br>Person()<br>Student(const char* name)<br>~Student()<br>~Person()</p><p><em>分析：基类是派生类的一部分，创建派生类对象时必须调用派生类构造函数，而派生类构造函数必须使用基类的构造函数。程序首先创建基类对象，所以基类对象在程序进入派生类构造函数之前被创建。实际上C++使用成员初始化列表语法来完成这项工作，即Person()相当于在函数Student()的初始化列表中被使用，如果不调用基类构造函数，程序将使用默认的基类构造函数。在执行完Person()的函数体之后，继承的数据成员被初始化，执行Student()函数体初始化新增的数据成员。析构对象时，先调用派生类的析构函数，执行完函数体析构完新增部分之后，使用基类的析构函数析构继承自基类的部分。</em></p><p><strong>总结：创建派生类对象时程序调用派生类构造函数，然后在初始化列表部分调用基类构造函数初始化继承的数据成员，而派生类构造函数主要初始化新增的数据成员。派生类总是调用一个基类构造函数。可以使用初始化列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将先调用派生类析构函数，在函数体执行完之后调用基类析构函数。（可以看到，继承的数据成员生命周期长， 新增的数据成员生命周期短。）</strong><br>2.拷贝构造函数<br>使用情况：<br>1.将新的对象初始化为一个同类对象<br>2.按值将对象传递给函数<br>3.函数按值返回对象<br>4.编译器生成临时对象<br><strong>注意：如果基类中没有指针成员，可以使用浅拷贝，如果有指针成员，必须要进行显式定义拷贝构造函数，即进行深拷贝。不然会造成同一块内存空间被析构两次的问题。</strong><br>3.赋值操作符<br>        默认的赋值操作符用于处理同类对象之间的赋值，赋值不是初始化，如果语句创建新的对象，则使用初始化，如果语句修改已有对象的值，则为赋值。 赋值运算符是不能被继承的，原因很简单。派生类继承的方法的特征与基类完全相同，但赋值操作符的特征随类而异，因为它包含一个类型为其所属类的形参。<br> <strong>注意：赋值运算和拷贝构造是不同的，赋值是赋值给一个已有对象，拷贝构造是构造一个全新的对象</strong><br> 将派生类赋值给基类对象：<br> <img src="https://img-blog.csdnimg.cn/2019042316362144.png" alt="在这里插入图片描述"><br>基类对象赋值给派生类对象：<br><img src="https://img-blog.csdnimg.cn/20190423163845421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbl9zaGlfbGVp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：<br><strong>是否可以将基类对象赋给派生类对象，答案是也许。如果派生类包含了转换构造函数，即对基类对象转换为派生类对象进行了定义，则可以将基类对象赋给派生对象。</strong><br>派生类对象可以赋给基类对象。<br><strong>五.c++作用域与重定义，赋值兼容规则</strong><br>1.作用域与重定义（同名隐藏）<br>当我们在派生类中定义一个同名函数的时候，编译器是将同名函数隐藏了，不管参数表是否相同。即不会构成函数重载，直接将基类函数覆盖。<br>那问什么构不成函数重载呢？<br><strong>一定要注意，函数重载的条件是在同一个作用域中才会构成函数重载，而派生类和基类是两个类域，一定不会构成函数重载的。</strong><br>2.继承与转换——赋值兼容规则（public继承为例）<br>基类和派生类的特殊关系：<br>1.派生类对象可以赋值给基类对象 ;基类对象不能赋值给派生类。<br>2.基类指针可以在不进行显示类型转换的情况下指向派生类对象 。<br>3.基类引用可以在不进行显示类型转换的情况下引用派生类对象，但是基类指针或引用只能用于调用基类的方法，不能用基类指针或引用调用派生类的成员及方法。<br><strong>C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是个例外。但是这个例外是单向的，即仅仅不可以将基类对象和地址赋给派生类引用和指针。如果允许基类引用隐式的引用派生类对象，则可以使用基类引用为派生类对象调用基类的方法，因为派生类继承了基类的方法，所以这样不会出现问题。但是如果可以将基类对象赋给派生类引用，那么派生类引用能够为积类对象调用派生类方法，这样做会出现问题，例如：用基类对象调用派生类中新增的方法，是没有意义的，因为基类对象中根本没有派生类的新增方法。</strong><br>3.友员与继承<br>友元关系不能继承， 也就是说基类友元不能访问子类私有和保护成员 。友元只是能访问指定类的私有和保护成员的自定义函数，不是被指定类的成员，自然不能继承。<br><strong>应该注意：</strong><br>(1) 友元关系不能被继承。<br>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。<br>(3)友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明<br>(4)友元可以访问类的私有成员。<br>(5)友元只能出现在类定义内部，友元声明可以在类中的任何地方，一般放在类定义的开始或结尾。<br>(6)友元可以是普通的非成员函数，或前面定义的其他类的成员函数，或整个类。<br>(7)类必须将重载函数集中每一个希望设为友元的函数都声明为友元。<br>(8)友元关系不能继承，基类的友元对派生类的成员没有特殊的访问权限。如果基类被授予友元关系，则只有基类具有特殊的访问权限。该基类的派生类不能访问授予友元关系的类。<br><strong>4.继承与静态成员</strong><br>        基类定义了 static成员 ， 则整个继承体系里面只 有一个这样的成员 。 无论派生出多少个子类， 都只有 一个static成员 实例。父类的static变量和函数在派生类中依然可用，但是受访问性控制（比如，父类的private域中的就不可访问）。而且对static变量来说，派生类和父类中的static变量是共用空间的，这点在利用static变量进行引用计数的时候要特别注意。派生类的friend函数可以访问派生类本身的一切变量，包括从父类继承下来的protected域中的变量。但是对父类来说，他并不是friend的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿&lt;strong&gt;一.基本概念：&lt;/strong&gt;&lt;br&gt;1.一个类可以继承另一个类，继承的类称为派生类（子类）、被继承的类称之为基类（父类）。&lt;br&gt;2.子类继承了父类所有成员，除了构造函数和赋值运算符重载。&lt;br&gt;3.子类继承父类后，子类的成员分为两部分（1）继承之父类
      
    
    </summary>
    
    
      <category term="C++" scheme="http://lovemonths.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>用栈、递归实现二叉树的前序、中序、后序遍历</title>
    <link href="http://lovemonths.com/2019/04/17/newpapername/"/>
    <id>http://lovemonths.com/2019/04/17/newpapername/</id>
    <published>2019-04-17T13:26:51.000Z</published>
    <updated>2019-04-17T13:33:57.888Z</updated>
    
    <content type="html"><![CDATA[<p>##题目一：二叉树的前序遍历</p><p>给定一个二叉树，返回它的前序遍历<br>示例：<br>输入: [1,null,2,3]<br>1</p><p>2<br>/<br>3</p><p>输出: [1,2,3]<br>代码实现如下：</p><p><code>/**</code></p><ul><li><p><code>Definition for a binary tree node.</code></p></li><li><p><code>struct TreeNode {</code></p></li><li><p><code>int val;</code></p></li><li><p><code>TreeNode *left;</code></p></li><li><p><code>TreeNode *right;</code></p></li><li><p><code>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</code></p></li><li><p><code>};</code><br> <code>*/</code><br> <code>class Solution {</code><br> <code>public:</code><br> <code>vector&lt;int&gt; preorderTraversal(TreeNode* root) {</code></p><pre><code>stack&lt;TreeNode*&gt; st;vector&lt;int&gt; v;if(root == nullptr){    return v;}if(root != nullptr){    //先将跟压到栈中    st.push(root);    while(!st.empty()){        TreeNode* cur = st.top();        //取出根并将根尾插到vector中        v.push_back(cur-&gt;val);        st.pop();        //先将cur-&gt;right压到栈中        if(cur-&gt;right){            st.push(cur-&gt;right);        }        //再将cur-&gt;left压到栈中，此时cur-&gt;left再栈顶，下次取出        //cur-&gt;left尾插到vector中，当左子树全部被取完，然后取右子        //树        if(cur-&gt;left){            st.push(cur-&gt;left);        }    }}return v;</code></pre><p> <code>}</code><br> <code>};</code></p><p> ##题目二：二叉树的中序遍历</p></li></ul><p>给定一个二叉树，返回它的中序遍历。<br>示例：<br>输入: [1,null,2,3]<br>1</p><p>2<br>/<br>3</p><p>输出: [1,3,2]<br>代码实现如下：</p><p><code>/**</code></p><ul><li><code>Definition for a binary tree node.</code></li><li><code>struct TreeNode {</code></li><li><code>int val;</code></li><li><code>TreeNode *left;</code></li><li><code>TreeNode *right;</code></li><li><code>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</code></li><li><p><code>};</code><br> <code>*/</code><br> <code>class Solution {</code><br> <code>public:</code><br> <code>vector&lt;int&gt; inorderTraversal(TreeNode* root) {</code></p><pre><code>stack&lt;TreeNode*&gt; st;vector&lt;int&gt; v;TreeNode* p = root;if(nullptr == root){    return v;}if(nullptr != root){    while(p != nullptr || !st.empty()){        //p不为空，压入栈中，p走左子树，将左子树全部压到栈中        while(p != nullptr){            //先压根            st.push(p);            p = p-&gt;left;        }        //取出栈顶元素给p，并将栈顶元素取出插入到vector中         p = st.top();        v.push_back(p-&gt;val);        st.pop();        //取出p-&gt;right压到栈中        p = p-&gt;right;    }}return v;</code></pre><p> <code>}</code><br> <code>};</code></p><p> ##题目三：二叉树的后序遍历</p></li></ul><p>给定一个二叉树,返回它的后序遍历。<br>示例：<br>输入: [1,null,2,3]<br>1</p><p>2<br>/<br>3</p><p>输出: [3,2,1]<br>用两个栈和递归实现二叉树的后续遍历。<br>代码实现如下：</p><p><code>/**</code></p><ul><li><code>Definition for a binary tree node.</code></li><li><code>struct TreeNode {</code></li><li><code>int val;</code></li><li><code>TreeNode *left;</code></li><li><code>TreeNode *right;</code></li><li><code>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</code></li><li><code>};</code><br> <code>*/</code><br> <code>class Solution {</code><br> <code>public:</code><br> <code>vector&lt;int&gt; postorderTraversal(TreeNode* root) {</code><pre><code>stack&lt;TreeNode*&gt; s1;stack&lt;TreeNode*&gt; s2;vector&lt;int&gt; res;if(!root){    return res;}s1.push(root);while(!s1.empty()){    TreeNode* cur = s1.top();    s1.pop();    s2.push(cur);    //先将left压到栈里，再将right压到栈里，然后取出将右子树压到s2    //中，最后再压左子树    //待右子树全部压完，然后将左子树全部压到栈s2中    //此时栈s2从上到下依次是左子树、右子树、根    if(cur-&gt;left){        s1.push(cur-&gt;left);    }    //后压右子树，然后全部将有子树压到栈s2中    if(cur-&gt;right){        s1.push(cur-&gt;right);    }}while(!s2.empty()){    //弹出s2栈顶元素，依次尾插到vector中，最终得到二叉树的后序    //遍历    res.push_back(s2.top()-&gt;val);    s2.pop();}return res;</code></pre> <code>}</code><br> <code>};</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##题目一：二叉树的前序遍历&lt;/p&gt;
&lt;p&gt;给定一个二叉树，返回它的前序遍历&lt;br&gt;示例：&lt;br&gt;输入: [1,null,2,3]&lt;br&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;br&gt;/&lt;br&gt;3&lt;/p&gt;
&lt;p&gt;输出: [1,2,3]&lt;br&gt;代码实现如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/**&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://lovemonths.com/tags/C/"/>
    
  </entry>
  
</feed>
