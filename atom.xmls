<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lovemonths</title>
  
  
  <link href="/atom.xmls" rel="self"/>
  
  <link href="http://lovemonths.com/"/>
  <updated>2019-04-23T11:52:38.224Z</updated>
  <id>http://lovemonths.com/</id>
  
  <author>
    <name>������</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux基本操作指令</title>
    <link href="http://lovemonths.com/2019/04/23/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/"/>
    <id>http://lovemonths.com/2019/04/23/linux基本操作指令/</id>
    <published>2019-04-23T11:50:10.000Z</published>
    <updated>2019-04-23T11:52:38.224Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一. 目录操作命令</strong></p><p><strong>1.列目录内容（ls）</strong></p><p>1）功能和用法</p><p>ls（list）的功能是列指定目录的内容，并将输出按某种方式排序。若不指定目录，则默认为当前目录。</p><p>​                 <code>ls [options][files]</code></p><p>2)  参数说明</p><p>ls的部分命令参数如下表：</p><ul><li>-a 列出目录下的所有文件，包括以 . 开头的隐含文件。 </li><li>-d 将目录象文件一样显示，而不是显示其下的文件。 如：ls –d 指定目录 </li><li>-i 输出文件的 i 节点的索引信息。 如 ls –ai 指定文件 </li><li>-k 以 k 字节的形式表示文件的大小。ls –alk 指定文件 </li><li>-l 列出文件的详细信息。 </li><li>-n 用数字的 UID,GID 代替名称。</li><li>-F 在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表 示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)。（目录类型识别） </li><li>-r 对目录反向排序。 </li><li>-t 以时间排序。 </li><li>-s 在l文件名后输出该文件的大小。（大小排序，如何找到目录下大的文件） </li><li>-1 一行只输出一个文件。 </li></ul><p>3)  举例</p><p>​                <code>ls -1</code></p><p><strong>2.建立目录（mkdir）</strong></p><p>1）功能与用法</p><p>​        mkdir（make directory)命令的功能是创建子目录，一次可以创建一个或多个子目录，还可以一次去创建包括全部父目录和子目录在内的一个完整的目录结构，它的使用受权限的制约。mkdir的用法为：</p><p>​          <code>mkdir [-p][-m MODE] dirs</code></p><p>2)   参数说明</p><p>​      -p：如果要创建的目录存在也不报错，则必要时可一同创建父目录。-m，–mode=MODE：按照权限MODE创建子目录。</p><p>3）举例</p><p>​       <code>$mkdir  temp        #在工作目录下，建立一个名为temp的子目录</code></p><p>​       <code>$mkdir temp1 temp2 temp3     #一次创建多个目录</code></p><p>​       <code>$mkdir  -p  temp4/child    #在temp4下创建子目录child，没有-p参数，父目录如果不存在，</code></p><p>​       <code>#将导致创建失败</code></p><p><strong>3.改变工作目录</strong></p><p>​       cd（change directory)命令是改变用户的当前工作目录。它的使用受权限制约，用户必须对要进入的目录有执行权。其用法为：</p><p>​                  <code>cd  [dir]</code></p><p><strong>4.显示当前目录（pwd）</strong></p><p>​    pwd（print working directory)命令的功能是显示当前目录。其用法为：</p><p>​                <code>pwd[-P][-L]</code></p><p>选项-P,-L分别显示当前目录的物理和逻辑位置，默认为后者。</p><p><strong>二. 文件操作基本命令</strong></p><p><strong>1.显示文件的内容或合并文件（cat）</strong></p><p>1) 功能和用法</p><p>​        cat（catenate）命令用来把文件内容显示到屏幕上，也可以同时显示多个文件。当不带参数运行cat时使用标准输入。使用cat通过I/O重定向的方法将多个文件的显示内容改到某个文件中，从而实现文件合并。cat的用法为：</p><p>​            <code>cat [options][files]</code></p><p>2) 举例</p><p>​            <code>$cat -n test.txt   #显示文件test.txt的内容，并为所有行添加行号</code></p><p><strong>2.浏览文件(less)</strong></p><p>​    less 命令和more一样都有分页处理命令，但less比more功能更强大。它可以使用PgUp和PgUn翻页，使用HOME和END直接跳到文件开始或结尾。</p><p>​     less命令是许多程序的（如man）等使用的默认的分页处理命令。如果想阅读压缩文件，它会调用less命令来处理。</p><p><strong>3.文件移动或更名（mv）</strong></p><p>1）功能和用法</p><p>mv（move）命令的功能是文件位置移动或更名。其用法为：</p><p>​         mv [options]  source  dest</p><p>​         mv [options]  source … directory</p><p>​         第一种用法是将源文件移动到目的文件，可用于文件移动或更名；第二种用法是将一批文件移动到某个目录directory。mv命令是有副作用的，但可以通过备份的方式避免。</p><p>​         mv 至少需要两个参数，一个用于源文件，另一个是目标文件或位置，若目标为当前目录可用</p><p>“ . ”表示，但不能省略。</p><p>2）举例</p><p>​       <code>$mv file1 file2        #若file2存在，则在不使用备份时将被覆盖</code></p><p>​       <code>$mv myfile /tmp/tmpf    #将myfile移动至/tmp/tmpf 下或更名为/tmp/tmpf</code></p><p>​       <code>$mv file1 file2 mydir       #将文件file1，file2移动到目录mydir下</code></p><p>​       <code>$mv  -bf  -V&quot;t&quot; file1 file2 mydir #以备份方式移动文件</code></p><p><strong>4.文件和目录复制（cp）</strong></p><p>1）功能和用法</p><p>​        cp（copy）命令的功能是文件目录复制。不能复制设备文件，但却可复制设备文件的内容以构造映像。其用法为：</p><p>​         <code>cp [options]  source  dest</code></p><p>​         <code>cp [options]  source ... directory</code></p><p>​         第一种用法是将源文件移动到目的文；第二种用法是将一批文件复制到某个目录directory。cp命令也有副作用的，但可以通过备份的方式避免。</p><p>​         cp 至少需要两个参数，一个用于源文件，另一个是目标文件或位置，若目标为当前目录可用</p><p>“ . ”表示，但不能省略。</p><p>2）举例</p><p>​           <code>$cp file1 file2       #将文件file1复制到file2，默认采用交互方式</code></p><p>​           <code>$cp /tmp/myp.c .    #将文件/tmp/myp.c 复制到当前目录</code></p><p>​           <code>$cp  file1 /tmp/file2 #将文件复制到/tmp并更名为file2</code></p><p>​           <code>$cp -rp file1 file2 #将文件file复制到目录file2中，且保持原有属性</code> </p><p><strong>5.修改文件存取时间或创建空文件（touch）</strong></p><p>1）功能和用法</p><p>​       touch命令的功能有两点：一是建立空文件；二是更新文件的存取时间。默认时，将文件属性中的3个时间都修改为系统的当前时间。若指定文件不存在，则创建空文件。</p><p>2）举例</p><p>​          <code>$touch myfile          #将文件的访问时间等改为当前时间，若不存在则创建</code></p><p>​          <code>$touch -a -t 200601020030 myfile yourfile  #修改文件的存取时间</code></p><p>​          <code>$touch -m -t 200706050403 myfile  #修改文件的修改时间</code></p><p><strong>6.rmdir指令 &amp;&amp; rm 指令</strong></p><p>rmdir是一个与mkdir相对应的命令。mkdir是建立目录，而rmdir是删除命令。 </p><p>1)rm命令的使用方式：</p><p>​          <code>rm [options] files</code></p><p>2)举例</p><p>​               <code>$rm -rf  file       #强制删除</code></p><p>​               <code>$rm -r file         #递归删除</code></p><p><strong>7.man指令</strong></p><p>查手册指令</p><p>举例：</p><p>​                <code>$ man  open</code></p><p><strong>8.清屏指令</strong></p><p>​       clear  或者  CTRL  L</p><p><strong>9.字符串或变量输出指令（echo）</strong></p><p>1）功能与用法</p><p>​      echo命令将其命令行参数中的字符串或变量的值写到标准输出。默认情况下，每个echo命令执行完毕后会产生一个换行符，如果不带参数执行此命令，将输出一个空行。echo命令的使用方式为：</p><p>​               <code>echo [options] string ...</code></p><p>2)举例</p><p>​            <code>$echo &quot;my name is Bill Joy&quot;    #以上命令的输出在同一行上</code></p><p>​            <code>$echo -n &quot;my name is Bill Joy&quot;   #不处理换行</code></p><p><strong>10.日期与时间管理指令</strong></p><p>1）功能与用法</p><p>date命令的用法为：</p><p>​      <code>date [options][+FORMAT]</code></p><p>​       <code>date[-u|--utc|--universal][MMDDhhmm][[CC]YY][.ss]</code></p><p>2) 举例</p><p>​       <code>$date     #以默认格式显示系统的当前时间</code></p><p>​       <code>$date 05311010  #设置系统的当前时间为当年5月31日10:10:00</code></p><p>​       <code>$date -s  &quot;+2 mintes&quot;    #将系统的时间前提两分</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一. 目录操作命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.列目录内容（ls）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）功能和用法&lt;/p&gt;
&lt;p&gt;ls（list）的功能是列指定目录的内容，并将输出按某种方式排序。若不指定目录，则默认为当前目录。&lt;/p
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://lovemonths.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++继承</title>
    <link href="http://lovemonths.com/2019/04/23/%E7%BB%A7%E6%89%BF/"/>
    <id>http://lovemonths.com/2019/04/23/继承/</id>
    <published>2019-04-23T09:12:37.000Z</published>
    <updated>2019-04-23T09:32:11.784Z</updated>
    
    <content type="html"><![CDATA[<p>﻿<strong>一.基本概念：</strong><br>1.一个类可以继承另一个类，继承的类称为派生类（子类）、被继承的类称之为基类（父类）。<br>2.子类继承了父类所有成员，除了构造函数和赋值运算符重载。<br>3.子类继承父类后，子类的成员分为两部分（1）继承之父类的部分base part（2）子类自己扩展的部分 appendent part<br>4.子类继承父类后，子类依然不能访问父类的私有成员，子类只能通过继承之父类的公有成员来访问父类的私有成员。<br>5.子类可以实现与父类成员函数原型相同的函数称为重写（覆盖）overwrite。<br>6.子类调子类的，父类不能调子类的，子类可以调用被覆盖的父类版本的函数，使用子类对象名.父类名：：函数名，比如：s.farther::print();<br>7.子类通过父类的私有成员的两种方式：<br>（1）通过父类的公有成员函数<br>（2）将私有成员改成保护成员protected<br><strong>二.继承的使用</strong><br>1.继承使用的两种情况：<br>（1）类之间有自然的继承关系，一个类是另一个类的特例，比如：一个学生是一个人。<br>（2）实现代码复用，一个类需要使用一个类的成员时。<br>2.继承的好处：<br>（1）代码复用<br>（2）使代码修改更容易<br>3.两个类之间的交互关系<br>（1）组合类 一个类中有另一个类的对象 has-a<br>（2）继承类 一个类是另一个类的特例        is-a<br><strong>三.c++的三种继承</strong><br>（1）公有继承（public）<br>公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。<br>（2）保护继承（protected）<br>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。<br>（3）私有继承（private）<br>私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。<br><strong>总结：</strong>private能够对外部和子类保密，即除了成员所在的类本身可以访问之外，别的都不能直接访问。protected能够对外部保密，但允许子类直接访问这些成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Base    //父类</span><br><span class="line">  &#123;</span><br><span class="line">    private: </span><br><span class="line">         int _priB;</span><br><span class="line">     protected:</span><br><span class="line">         int _proB;</span><br><span class="line">     public:</span><br><span class="line">        int _pubB;</span><br><span class="line">  &#125; ;</span><br><span class="line"> class Derived: public Base    //子类，继承自base,继承类型为公有继承</span><br><span class="line"> &#123;</span><br><span class="line">    private:</span><br><span class="line">       int _d_pri;</span><br><span class="line">    protected:</span><br><span class="line">       int _d_pro;</span><br><span class="line">    public:</span><br><span class="line">        void funct()</span><br><span class="line">     &#123;</span><br><span class="line">         int d;</span><br><span class="line">         d=_priB;       //error：基类中私有成员在派生类中是不可见的</span><br><span class="line">         d=_proB;       //ok： 基类的保护成员在派生类中为保护成员</span><br><span class="line">         d=_pubB;       //ok： 基类的公共成员在派生类中为公共成员</span><br><span class="line">     &#125;</span><br><span class="line">       int _d_pub;</span><br><span class="line"> &#125; ;</span><br></pre></td></tr></table></figure><p>总结：（1）. public继承是一个接口继承，保持is-a原则，每个父类可用的成员对子类也可用， 因为每个子类对象也都是一个父类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class C :private Base    //基类Base的派生类C（私有继承）</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void funct()</span><br><span class="line">    &#123;</span><br><span class="line">        int c;</span><br><span class="line">        c=_priB;      //error：基类中私有成员在派生类中是不可见的</span><br><span class="line">        c=_proB;      //ok：基类的保护成员在派生类中为私有成员</span><br><span class="line">        c=_pubB;      //ok：基类的公共成员在派生类中为私有成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class E :protected Base   //基类Base的派生类E（保护继承）</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void funct()</span><br><span class="line">    &#123;</span><br><span class="line">        int e ;</span><br><span class="line">        e=_priB;    //error：基类中私有成员在派生类中是不可见的</span><br><span class="line">        e=_proB;    //ok：基类的保护成员在派生类中为保护成员</span><br><span class="line">        e=_pubB;    //ok：基类的公共成员在派生类中为保护成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：<br>（2）. 基类的private成员 在派生类中是不能被访问的， 如果基类成员 不想在类外直接被访问， 但需要 在派生类中能访问， 就定义为protected。 可以看出保护成员 限定符是因继承才出现的。<br>（3）. protected/private继承是一个实现继承， 基类的部分成员 并非完全成为子类接口 的一部分， 是 has-a 的关系原则， 所以非特殊情况下不会使用这两种继承关系， 在绝大多数的场景下使用的 都是公有继承。 私有继承以为这is-implemented-in-terms-of(是根据……实现的) 。 通常比组合(composition) 更低级， 但当一个派生类需要访问 基类保护成员 或需要重定义基类的虚函数时它就是合理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     int a; </span><br><span class="line">     D d;</span><br><span class="line">     a=D._priB;     //error：公有继承基类中私有成员在派生类中是不可见的,对对象不可见     </span><br><span class="line">     a=D._proB;           //error：公有继承基类的保护成员在派生类中为保护成员，对对象不可见</span><br><span class="line">     a=D._pubB;     //ok：公有继承基类的公共成员在派生类中为公共成员，对对象可见</span><br><span class="line">     C c;</span><br><span class="line">     a=c._priB;    //error：私有继承基类中私有成员在派生类中是不可见的, 对对象不可见</span><br><span class="line">     a=c._proB;    //error：私有继承基类的保护成员在派生类中为私有成员，对对象不可见</span><br><span class="line">     a=c._pubB;    //error：私有继承基类的公共成员在派生类中为私有成员，对对象不可见</span><br><span class="line">     E e;</span><br><span class="line">     a=e._priB;    //error：保护继承基类中私有成员在派生类中是不可见的, 对对象不可见</span><br><span class="line">     a=e._proB;    //error：保护继承基类的保护成员在派生类中为保护成员，对对象不可见   </span><br><span class="line">     a=e._pubB;    //error：保护继承基类的公共成员在派生类中为保护成员，对对象不可见</span><br><span class="line"></span><br><span class="line">​     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>（4）. 不管是哪种继承方式， 在派生类内部都可以访问基类的公有成员和保护成员 ， 基类的私有成员存在但是在子类中不可见（ 不能访问） 。<br>（5）. 使用关键字class时默认的继承方式是private， 使用struct时默认的继承方式是public， 不过最好显式的写出继承方式。<br>（6）. 在实际运用中一般使用都是public继承， 极少场景下才会使用protetced/private继承。</p><p>在struct继承中，如果没有显式给出继承类型，则默认的为public继承；在class继承中，如果没有显式给出继承类型，则默认的为private继承；<br><strong>四.派生类的默认成员函数</strong><br>1.构造与析构的调用关系<br>先看一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(const char* name = &quot;hello&quot;)</span><br><span class="line">: _name(name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Person() // ~destructor</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">string _name; // 姓名</span><br><span class="line">&#125;;</span><br><span class="line">class Student : public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Student(const char* name = &quot;helo&quot;)</span><br><span class="line">:_id(10)</span><br><span class="line">,Person(name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Student(const char* name)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Student()  // ~destructor  同名隐藏，编译器底层对析构函数的名字做了修改，为了使用多态</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;~Student()&quot; &lt;&lt; endl;</span><br><span class="line">//Person::~Person();</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int _id;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Student s;</span><br><span class="line">return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br>Person()<br>Student(const char* name)<br>~Student()<br>~Person()</p><p><em>分析：基类是派生类的一部分，创建派生类对象时必须调用派生类构造函数，而派生类构造函数必须使用基类的构造函数。程序首先创建基类对象，所以基类对象在程序进入派生类构造函数之前被创建。实际上C++使用成员初始化列表语法来完成这项工作，即Person()相当于在函数Student()的初始化列表中被使用，如果不调用基类构造函数，程序将使用默认的基类构造函数。在执行完Person()的函数体之后，继承的数据成员被初始化，执行Student()函数体初始化新增的数据成员。析构对象时，先调用派生类的析构函数，执行完函数体析构完新增部分之后，使用基类的析构函数析构继承自基类的部分。</em></p><p><strong>总结：创建派生类对象时程序调用派生类构造函数，然后在初始化列表部分调用基类构造函数初始化继承的数据成员，而派生类构造函数主要初始化新增的数据成员。派生类总是调用一个基类构造函数。可以使用初始化列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将先调用派生类析构函数，在函数体执行完之后调用基类析构函数。（可以看到，继承的数据成员生命周期长， 新增的数据成员生命周期短。）</strong><br>2.拷贝构造函数<br>使用情况：<br>1.将新的对象初始化为一个同类对象<br>2.按值将对象传递给函数<br>3.函数按值返回对象<br>4.编译器生成临时对象<br><strong>注意：如果基类中没有指针成员，可以使用浅拷贝，如果有指针成员，必须要进行显式定义拷贝构造函数，即进行深拷贝。不然会造成同一块内存空间被析构两次的问题。</strong><br>3.赋值操作符<br>        默认的赋值操作符用于处理同类对象之间的赋值，赋值不是初始化，如果语句创建新的对象，则使用初始化，如果语句修改已有对象的值，则为赋值。 赋值运算符是不能被继承的，原因很简单。派生类继承的方法的特征与基类完全相同，但赋值操作符的特征随类而异，因为它包含一个类型为其所属类的形参。<br> <strong>注意：赋值运算和拷贝构造是不同的，赋值是赋值给一个已有对象，拷贝构造是构造一个全新的对象</strong><br> 将派生类赋值给基类对象：<br> <img src="https://img-blog.csdnimg.cn/2019042316362144.png" alt="在这里插入图片描述"><br>基类对象赋值给派生类对象：<br><img src="https://img-blog.csdnimg.cn/20190423163845421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbl9zaGlfbGVp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：<br><strong>是否可以将基类对象赋给派生类对象，答案是也许。如果派生类包含了转换构造函数，即对基类对象转换为派生类对象进行了定义，则可以将基类对象赋给派生对象。</strong><br>派生类对象可以赋给基类对象。<br><strong>五.c++作用域与重定义，赋值兼容规则</strong><br>1.作用域与重定义（同名隐藏）<br>当我们在派生类中定义一个同名函数的时候，编译器是将同名函数隐藏了，不管参数表是否相同。即不会构成函数重载，直接将基类函数覆盖。<br>那问什么构不成函数重载呢？<br><strong>一定要注意，函数重载的条件是在同一个作用域中才会构成函数重载，而派生类和基类是两个类域，一定不会构成函数重载的。</strong><br>2.继承与转换——赋值兼容规则（public继承为例）<br>基类和派生类的特殊关系：<br>1.派生类对象可以赋值给基类对象 ;基类对象不能赋值给派生类。<br>2.基类指针可以在不进行显示类型转换的情况下指向派生类对象 。<br>3.基类引用可以在不进行显示类型转换的情况下引用派生类对象，但是基类指针或引用只能用于调用基类的方法，不能用基类指针或引用调用派生类的成员及方法。<br><strong>C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是个例外。但是这个例外是单向的，即仅仅不可以将基类对象和地址赋给派生类引用和指针。如果允许基类引用隐式的引用派生类对象，则可以使用基类引用为派生类对象调用基类的方法，因为派生类继承了基类的方法，所以这样不会出现问题。但是如果可以将基类对象赋给派生类引用，那么派生类引用能够为积类对象调用派生类方法，这样做会出现问题，例如：用基类对象调用派生类中新增的方法，是没有意义的，因为基类对象中根本没有派生类的新增方法。</strong><br>3.友员与继承<br>友元关系不能继承， 也就是说基类友元不能访问子类私有和保护成员 。友元只是能访问指定类的私有和保护成员的自定义函数，不是被指定类的成员，自然不能继承。<br><strong>应该注意：</strong><br>(1) 友元关系不能被继承。<br>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。<br>(3)友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明<br>(4)友元可以访问类的私有成员。<br>(5)友元只能出现在类定义内部，友元声明可以在类中的任何地方，一般放在类定义的开始或结尾。<br>(6)友元可以是普通的非成员函数，或前面定义的其他类的成员函数，或整个类。<br>(7)类必须将重载函数集中每一个希望设为友元的函数都声明为友元。<br>(8)友元关系不能继承，基类的友元对派生类的成员没有特殊的访问权限。如果基类被授予友元关系，则只有基类具有特殊的访问权限。该基类的派生类不能访问授予友元关系的类。<br><strong>4.继承与静态成员</strong><br>        基类定义了 static成员 ， 则整个继承体系里面只 有一个这样的成员 。 无论派生出多少个子类， 都只有 一个static成员 实例。父类的static变量和函数在派生类中依然可用，但是受访问性控制（比如，父类的private域中的就不可访问）。而且对static变量来说，派生类和父类中的static变量是共用空间的，这点在利用static变量进行引用计数的时候要特别注意。派生类的friend函数可以访问派生类本身的一切变量，包括从父类继承下来的protected域中的变量。但是对父类来说，他并不是friend的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿&lt;strong&gt;一.基本概念：&lt;/strong&gt;&lt;br&gt;1.一个类可以继承另一个类，继承的类称为派生类（子类）、被继承的类称之为基类（父类）。&lt;br&gt;2.子类继承了父类所有成员，除了构造函数和赋值运算符重载。&lt;br&gt;3.子类继承父类后，子类的成员分为两部分（1）继承之父类
      
    
    </summary>
    
    
      <category term="C++" scheme="http://lovemonths.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>用栈、递归实现二叉树的前序、中序、后序遍历</title>
    <link href="http://lovemonths.com/2019/04/17/newpapername/"/>
    <id>http://lovemonths.com/2019/04/17/newpapername/</id>
    <published>2019-04-17T13:26:51.000Z</published>
    <updated>2019-04-17T13:33:57.888Z</updated>
    
    <content type="html"><![CDATA[<p>##题目一：二叉树的前序遍历</p><p>给定一个二叉树，返回它的前序遍历<br>示例：<br>输入: [1,null,2,3]<br>1</p><p>2<br>/<br>3</p><p>输出: [1,2,3]<br>代码实现如下：</p><p><code>/**</code></p><ul><li><p><code>Definition for a binary tree node.</code></p></li><li><p><code>struct TreeNode {</code></p></li><li><p><code>int val;</code></p></li><li><p><code>TreeNode *left;</code></p></li><li><p><code>TreeNode *right;</code></p></li><li><p><code>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</code></p></li><li><p><code>};</code><br> <code>*/</code><br> <code>class Solution {</code><br> <code>public:</code><br> <code>vector&lt;int&gt; preorderTraversal(TreeNode* root) {</code></p><pre><code>stack&lt;TreeNode*&gt; st;vector&lt;int&gt; v;if(root == nullptr){    return v;}if(root != nullptr){    //先将跟压到栈中    st.push(root);    while(!st.empty()){        TreeNode* cur = st.top();        //取出根并将根尾插到vector中        v.push_back(cur-&gt;val);        st.pop();        //先将cur-&gt;right压到栈中        if(cur-&gt;right){            st.push(cur-&gt;right);        }        //再将cur-&gt;left压到栈中，此时cur-&gt;left再栈顶，下次取出        //cur-&gt;left尾插到vector中，当左子树全部被取完，然后取右子        //树        if(cur-&gt;left){            st.push(cur-&gt;left);        }    }}return v;</code></pre><p> <code>}</code><br> <code>};</code></p><p> ##题目二：二叉树的中序遍历</p></li></ul><p>给定一个二叉树，返回它的中序遍历。<br>示例：<br>输入: [1,null,2,3]<br>1</p><p>2<br>/<br>3</p><p>输出: [1,3,2]<br>代码实现如下：</p><p><code>/**</code></p><ul><li><code>Definition for a binary tree node.</code></li><li><code>struct TreeNode {</code></li><li><code>int val;</code></li><li><code>TreeNode *left;</code></li><li><code>TreeNode *right;</code></li><li><code>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</code></li><li><p><code>};</code><br> <code>*/</code><br> <code>class Solution {</code><br> <code>public:</code><br> <code>vector&lt;int&gt; inorderTraversal(TreeNode* root) {</code></p><pre><code>stack&lt;TreeNode*&gt; st;vector&lt;int&gt; v;TreeNode* p = root;if(nullptr == root){    return v;}if(nullptr != root){    while(p != nullptr || !st.empty()){        //p不为空，压入栈中，p走左子树，将左子树全部压到栈中        while(p != nullptr){            //先压根            st.push(p);            p = p-&gt;left;        }        //取出栈顶元素给p，并将栈顶元素取出插入到vector中         p = st.top();        v.push_back(p-&gt;val);        st.pop();        //取出p-&gt;right压到栈中        p = p-&gt;right;    }}return v;</code></pre><p> <code>}</code><br> <code>};</code></p><p> ##题目三：二叉树的后序遍历</p></li></ul><p>给定一个二叉树,返回它的后序遍历。<br>示例：<br>输入: [1,null,2,3]<br>1</p><p>2<br>/<br>3</p><p>输出: [3,2,1]<br>用两个栈和递归实现二叉树的后续遍历。<br>代码实现如下：</p><p><code>/**</code></p><ul><li><code>Definition for a binary tree node.</code></li><li><code>struct TreeNode {</code></li><li><code>int val;</code></li><li><code>TreeNode *left;</code></li><li><code>TreeNode *right;</code></li><li><code>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</code></li><li><code>};</code><br> <code>*/</code><br> <code>class Solution {</code><br> <code>public:</code><br> <code>vector&lt;int&gt; postorderTraversal(TreeNode* root) {</code><pre><code>stack&lt;TreeNode*&gt; s1;stack&lt;TreeNode*&gt; s2;vector&lt;int&gt; res;if(!root){    return res;}s1.push(root);while(!s1.empty()){    TreeNode* cur = s1.top();    s1.pop();    s2.push(cur);    //先将left压到栈里，再将right压到栈里，然后取出将右子树压到s2    //中，最后再压左子树    //待右子树全部压完，然后将左子树全部压到栈s2中    //此时栈s2从上到下依次是左子树、右子树、根    if(cur-&gt;left){        s1.push(cur-&gt;left);    }    //后压右子树，然后全部将有子树压到栈s2中    if(cur-&gt;right){        s1.push(cur-&gt;right);    }}while(!s2.empty()){    //弹出s2栈顶元素，依次尾插到vector中，最终得到二叉树的后序    //遍历    res.push_back(s2.top()-&gt;val);    s2.pop();}return res;</code></pre> <code>}</code><br> <code>};</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##题目一：二叉树的前序遍历&lt;/p&gt;
&lt;p&gt;给定一个二叉树，返回它的前序遍历&lt;br&gt;示例：&lt;br&gt;输入: [1,null,2,3]&lt;br&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;br&gt;/&lt;br&gt;3&lt;/p&gt;
&lt;p&gt;输出: [1,2,3]&lt;br&gt;代码实现如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/**&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://lovemonths.com/tags/C/"/>
    
  </entry>
  
</feed>
